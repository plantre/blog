<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java Q&amp;A | Overfly</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="note">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.eb5f38e4.css" as="style"><link rel="preload" href="/assets/js/app.05e9a5df.js" as="script"><link rel="preload" href="/assets/js/3.c925c384.js" as="script"><link rel="preload" href="/assets/js/1.9975a5e7.js" as="script"><link rel="preload" href="/assets/js/29.59e6b149.js" as="script"><link rel="prefetch" href="/assets/js/10.555bb3dd.js"><link rel="prefetch" href="/assets/js/11.c120359e.js"><link rel="prefetch" href="/assets/js/12.ad886030.js"><link rel="prefetch" href="/assets/js/13.d0777667.js"><link rel="prefetch" href="/assets/js/14.6c1a3ffa.js"><link rel="prefetch" href="/assets/js/15.7b9a9692.js"><link rel="prefetch" href="/assets/js/16.6f5dbf91.js"><link rel="prefetch" href="/assets/js/17.9acd08f6.js"><link rel="prefetch" href="/assets/js/18.bda725fe.js"><link rel="prefetch" href="/assets/js/19.ef19e8ce.js"><link rel="prefetch" href="/assets/js/20.93be3e1b.js"><link rel="prefetch" href="/assets/js/21.780a535b.js"><link rel="prefetch" href="/assets/js/22.25628208.js"><link rel="prefetch" href="/assets/js/23.64dc5354.js"><link rel="prefetch" href="/assets/js/24.a95ee7d3.js"><link rel="prefetch" href="/assets/js/25.f5a34804.js"><link rel="prefetch" href="/assets/js/26.c3286c78.js"><link rel="prefetch" href="/assets/js/27.f3c48b46.js"><link rel="prefetch" href="/assets/js/28.bb1619dc.js"><link rel="prefetch" href="/assets/js/30.c1dac843.js"><link rel="prefetch" href="/assets/js/31.374d1e46.js"><link rel="prefetch" href="/assets/js/32.a1821089.js"><link rel="prefetch" href="/assets/js/33.2aab4f19.js"><link rel="prefetch" href="/assets/js/34.cd7ac131.js"><link rel="prefetch" href="/assets/js/35.bbe62b13.js"><link rel="prefetch" href="/assets/js/36.0a1cd34b.js"><link rel="prefetch" href="/assets/js/37.c12ef26f.js"><link rel="prefetch" href="/assets/js/38.e70e7566.js"><link rel="prefetch" href="/assets/js/39.68ca1f39.js"><link rel="prefetch" href="/assets/js/4.f1a2d0e3.js"><link rel="prefetch" href="/assets/js/40.c3d0f2a1.js"><link rel="prefetch" href="/assets/js/41.7eab50b7.js"><link rel="prefetch" href="/assets/js/42.4719f4f5.js"><link rel="prefetch" href="/assets/js/43.fcea90e4.js"><link rel="prefetch" href="/assets/js/44.f2127464.js"><link rel="prefetch" href="/assets/js/45.2eac0f1c.js"><link rel="prefetch" href="/assets/js/46.97908625.js"><link rel="prefetch" href="/assets/js/47.ab37bc5f.js"><link rel="prefetch" href="/assets/js/48.0c7782e0.js"><link rel="prefetch" href="/assets/js/49.26bcae1d.js"><link rel="prefetch" href="/assets/js/5.a55da33a.js"><link rel="prefetch" href="/assets/js/50.d1ed5dd6.js"><link rel="prefetch" href="/assets/js/51.49872e4a.js"><link rel="prefetch" href="/assets/js/52.24e6994d.js"><link rel="prefetch" href="/assets/js/53.37f611f3.js"><link rel="prefetch" href="/assets/js/54.7ff499b2.js"><link rel="prefetch" href="/assets/js/55.675be805.js"><link rel="prefetch" href="/assets/js/56.7a98c9cc.js"><link rel="prefetch" href="/assets/js/57.ab21d575.js"><link rel="prefetch" href="/assets/js/58.5e4df500.js"><link rel="prefetch" href="/assets/js/59.c7be1d56.js"><link rel="prefetch" href="/assets/js/6.180231f1.js"><link rel="prefetch" href="/assets/js/60.f7786110.js"><link rel="prefetch" href="/assets/js/61.80b89a9d.js"><link rel="prefetch" href="/assets/js/62.3db93655.js"><link rel="prefetch" href="/assets/js/63.da888a6b.js"><link rel="prefetch" href="/assets/js/64.45fa7185.js"><link rel="prefetch" href="/assets/js/7.80061948.js"><link rel="prefetch" href="/assets/js/8.a920b205.js"><link rel="prefetch" href="/assets/js/9.0721afe9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.eb5f38e4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Overfly</h3> <p class="description" data-v-59e6cb88>note</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>wzg</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Overfly" class="logo"> <span class="site-name">Overfly</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Algorithm/" class="nav-link"><i class="undefined"></i>
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/categories/Base/" class="nav-link"><i class="undefined"></i>
  Base
</a></li><li class="dropdown-item"><!----> <a href="/categories/CloudNative/" class="nav-link"><i class="undefined"></i>
  CloudNative
</a></li><li class="dropdown-item"><!----> <a href="/categories/DesignPattern/" class="nav-link"><i class="undefined"></i>
  DesignPattern
</a></li><li class="dropdown-item"><!----> <a href="/categories/Devops/" class="nav-link"><i class="undefined"></i>
  Devops
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed/" class="nav-link"><i class="undefined"></i>
  Distributed
</a></li><li class="dropdown-item"><!----> <a href="/categories/Dubbo/" class="nav-link"><i class="undefined"></i>
  Dubbo
</a></li><li class="dropdown-item"><!----> <a href="/categories/Es/" class="nav-link"><i class="undefined"></i>
  Es
</a></li><li class="dropdown-item"><!----> <a href="/categories/Front/" class="nav-link"><i class="undefined"></i>
  Front
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/Linux/" class="nav-link"><i class="undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/categories/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/categories/MQ/" class="nav-link"><i class="undefined"></i>
  MQ
</a></li><li class="dropdown-item"><!----> <a href="/categories/Netty/" class="nav-link"><i class="undefined"></i>
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/categories/Others/" class="nav-link"><i class="undefined"></i>
  Others
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Spring/" class="nav-link"><i class="undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/categories/Tools/" class="nav-link"><i class="undefined"></i>
  Tools
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="undefined"></i>
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/categories/WorkFlow/" class="nav-link"><i class="undefined"></i>
  WorkFlow
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/plantre" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    wzg
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>54</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>38</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Algorithm/" class="nav-link"><i class="undefined"></i>
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/categories/Base/" class="nav-link"><i class="undefined"></i>
  Base
</a></li><li class="dropdown-item"><!----> <a href="/categories/CloudNative/" class="nav-link"><i class="undefined"></i>
  CloudNative
</a></li><li class="dropdown-item"><!----> <a href="/categories/DesignPattern/" class="nav-link"><i class="undefined"></i>
  DesignPattern
</a></li><li class="dropdown-item"><!----> <a href="/categories/Devops/" class="nav-link"><i class="undefined"></i>
  Devops
</a></li><li class="dropdown-item"><!----> <a href="/categories/Distributed/" class="nav-link"><i class="undefined"></i>
  Distributed
</a></li><li class="dropdown-item"><!----> <a href="/categories/Dubbo/" class="nav-link"><i class="undefined"></i>
  Dubbo
</a></li><li class="dropdown-item"><!----> <a href="/categories/Es/" class="nav-link"><i class="undefined"></i>
  Es
</a></li><li class="dropdown-item"><!----> <a href="/categories/Front/" class="nav-link"><i class="undefined"></i>
  Front
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/Linux/" class="nav-link"><i class="undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/categories/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/categories/MQ/" class="nav-link"><i class="undefined"></i>
  MQ
</a></li><li class="dropdown-item"><!----> <a href="/categories/Netty/" class="nav-link"><i class="undefined"></i>
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/categories/Others/" class="nav-link"><i class="undefined"></i>
  Others
</a></li><li class="dropdown-item"><!----> <a href="/categories/Redis/" class="nav-link"><i class="undefined"></i>
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/categories/Spring/" class="nav-link"><i class="undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/categories/Tools/" class="nav-link"><i class="undefined"></i>
  Tools
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zookeeper/" class="nav-link"><i class="undefined"></i>
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/categories/WorkFlow/" class="nav-link"><i class="undefined"></i>
  WorkFlow
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/plantre" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Java Q&amp;A</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>wzg</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">Java Q&amp;A</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>wzg</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>9/1/2022</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>Lang</span></i></div></div> <div class="theme-reco-content content__default"><p><strong>1、Java面向对象特性介绍、与C++区别</strong></p> <p>**特性：**封装、继承、多态</p> <p>​	**封装：**对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法，这样一个对象便有存在的意义了；</p> <p>​	**继承：**在已存在类的基础上，建立新类并对其增加新的数据域或功能，同时该类可以复用父类的属性与功能，这种思路可以称为继承；通过使用继承能够方便地复用旧代码，减少不必要的代码量；</p> <p>​	**多态：**指程序中的某个引用变量，它所指向的具体类型以及该引用变量发出的方法调用，在编程时不能确定，要在程序运行并使用时由机器自己判别确定；实现多态的方式有两种方式，可以通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）</p> <p><strong>Java与C++区别：</strong></p> <p>​	相同点：都是面向对象语言，并且都支持封装、继承、多态</p> <p>​	不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p> <p><strong>2、多态实现原理</strong></p> <p>参考：https://www.baidu.com/link?url=qCqeY8tJInTtjEXuotB712TJtEpKeLJ9ds1ACGEnYwMyJdjf6J0C7JvOEwbV7qNG&amp;wd=&amp;eqid=fe3b2106001ee6ab000000065f111b6c</p> <p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p> <p><strong>静态绑定与动态绑定：</strong></p> <p>​	JVM 的方法调用指令有五个，分别是：</p> <p>​		invokestatic：调用静态方法；</p> <p>​		invokespecial：调用实例构造器<init>方法、私有方法和父类方法；</init></p> <p>​		invokevirtual：调用虚方法；</p> <p>​		invokeinterface：调用接口方法，运行时确定具体实现；</p> <p>​		invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。</p> <p>​		invokestatic 和 invokespecial 用于静态绑定</p> <p>​		invokevirtual 和 invokeinterface 用于动态绑定</p> <p>​	可以看出，动态绑定主要应用于虚方法和接口方法。</p> <p>​	虚方法的方法调用与方法实现的关联（也就是分派）有两种，一种是在编译期确定，被称为静态分派，比如方法的重载；一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）。对象方法基本上都是虚方法。</p> <p><strong>多态的实现</strong></p> <p>​		虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，通过栈帧的信息去找到被调用方法的具体实现，然后使用这个具体实现的直接引用完成方法调用。</p> <p>以 invokevirtual 指令为例，在执行时，大致可以分为以下几步：</p> <ol><li>先从操作栈中找到对象的实际类型 class；</li> <li>找到 class 中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError ；</li> <li>如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作；</li> <li>如果第 3 步找不到相符的方法，就报错 java.lang.AbstractMethodError ；</li></ol> <p>可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p> <p><strong>3、抽象类和接口区别，以及各自的使用场景</strong></p> <p>**抽象类：**包含抽象方法的类，即使用abstract修饰的类；不能使用final修饰，final修饰的类不能被继承；抽象类不能被实例化，只能被继承</p> <p>**接口：**接口是一个抽象类型，是抽象方法的集合，接口以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法；接口只能继承接口，不能继承类，接口支持多继承；接口中的定义的成员变量，默认是public static final修饰的静态常量；接口中定义的方法，默认是public abstract修饰的抽象方法</p> <p><strong>相同点：</strong></p> <p>​	① 抽象类和接口都不能被实例化</p> <p>​	② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法</p> <p><strong>不同点：</strong></p> <p>​	① 抽象类有构造方法，接口没有构造方法</p> <p>​	③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p> <p>​	③ 抽象类只能单继承，接口可以多继承</p> <p>​	④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p> <p><strong>抽象类的使用场景：</strong></p> <p>​	既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p> <p><strong>接口的应用场景：</strong></p> <p>​	约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系</p> <p><strong>4、泛型以及泛型擦除。List<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？</A></strong></p> <p>参考：https://blog.csdn.net/baoyinwang/article/details/107341997</p> <p><strong>泛型：</strong></p> <p>​		泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p> <p><strong>泛型擦除：</strong></p> <p>​		Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p> <p>​		如在代码中定义的 List<Object>和 List<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</String></Object></p> <p><strong>如何加入：</strong></p> <p>​	通过反射添加其它类型元素</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这样调用 add 方法只能存储A，因为泛型类型的实例为 A</span>
 
        list<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span>
 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>5、Java异常体系</strong></p> <p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&amp;fm=26&amp;gp=0.jpg" alt=""></p> <p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p> <p><strong>Error ：</strong></p> <p>​		是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p> <p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p> <p><strong>RuntimeException：</strong> 运 行 时 异 常</p> <p>​	 如 NullPointerException 、 ClassCastException ；</p> <p>​	 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类，这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p> <p>**CheckedException：**受检异 常</p> <p>​		如 I/O 错误导致的 IOException、SQLException；</p> <p>​		CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类</p> <p>异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p> <p>​	  ①试图在文件尾部读取数据</p> <p>​	  ②试图打开一个错误格式的 URL</p> <p>​	  ③试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</p> <p><strong>6、反射原理以及使用场景</strong></p> <p><strong>Java反射：</strong></p> <p>​		是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p> <p><strong>反射原理：</strong></p> <p>​		反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p> <p>​	<strong>如何得到Class的实例:</strong></p> <div class="language- extra-class"><pre><code>	1.类名.class(就是一份字节码)
	2.Class.forName(String className);根据一个类的全限定名来构建Class对象
	3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型
</code></pre></div><p><strong>使用场景：</strong></p> <p>​		逆向代码 ，例如反编译；</p> <p>​		动态生成类框架，如Spring：xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p> <p><strong>7、ThreadLocal原理，如何使用？</strong></p> <p><strong>ThreadLocal简介：</strong></p> <p>​		通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的
专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。</p> <p><strong>原理：</strong></p> <p>​		首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p> <p>​		最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p> <p>​		我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的</p> <p><strong>set 方法：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>get方法：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>   
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
 
    <span class="token comment">// 如果不存在，则创建它   </span>
    <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>   
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>createMap方法：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
    t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>ThreadLocalMap是个静态的内部类：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>   
    ……  
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>如何使用：</strong></p> <p>​		1）存储用户Session</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span> threadSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Session</span> <span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InfrastructureException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Session</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Session</span><span class="token punctuation">)</span> threadSession<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s <span class="token operator">=</span> <span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threadSession<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">HibernateException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InfrastructureException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​		2）解决线程安全的问题</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateUtil</span> <span class="token punctuation">{</span>
    <span class="token comment">//SimpleDateFormat不是线程安全的，所以每个线程都要有⾃⼰独⽴的副本</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> format1 <span class="token operator">=</span> <span class="token keyword">new</span>                     <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">SimpleDateFormat</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">formatDate</span><span class="token punctuation">(</span><span class="token class-name">Date</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> format1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>8、ThreadLocal内存泄漏的场景</strong></p> <p>​		实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p> <p>​		所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。</p> <p>​		ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</p> <p>​		因此使⽤完ThreadLocal ⽅法后，最好⼿动调⽤ remove() ⽅法。</p> <p><strong>9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？</strong></p> <p>**static：**可以修饰属性、方法</p> <p>​	<strong>static修饰属性：</strong></p> <p>​		所有对象共享一份，一个对象对其修改，其他的调用也会受到影响，类级别；随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p> <p>​	<strong>static修饰方法：</strong></p> <p>​		随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员；非静态的方法中，可以调用静态和非静态的成员；在静态方法中，不会出现this。</p> <p>**final：**关键字主要⽤在三个地⽅：变量、⽅法、类。</p> <p>​	<strong>final修饰变量：</strong></p> <p>​		对于⼀个 final 变量，如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p> <p>​	<strong>final修饰方法：</strong></p> <p>​		把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p> <p>​	<strong>final修饰类：</strong></p> <p>​		 final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p> <p><strong>10、序列化和反序列化。反序列化失败的场景。</strong></p> <p>​		序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p> <p>**序列化：**将java对象转化为字节序列的过程。</p> <p>**反序列化：**将字节序列转化为java对象的过程。</p> <p><strong>优点：</strong></p> <p>​	a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）</p> <p>​	b、利用序列化实现远程通信，即在网络上传送对象的字节序列。</p> <p><strong>反序列化失败的场景：</strong></p> <p>​		序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p> <p><strong>11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？</strong></p> <p><strong>ArrayList：</strong></p> <p>​		底层基于数组实现，支持对元素进行快速随机访问，支持元素重复；默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p> <p><strong>LinkedList：</strong></p> <p>​		底层基于双向链表实现，适合数据的动态插入和删除；内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p> <p><strong>ArrayList与LinkedList区别：</strong></p> <p>​		都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于 增加、删除多的场景</p> <p><strong>实现线程安全：</strong></p> <p>​		可以使用原生的<strong>Vector</strong>，或者是<strong>Collections.synchronizedList(List list)<strong>函数返回一个线程安全的ArrayList集合，或者使用concurrent并发包下的</strong>CopyOnWriteArrayList</strong>的。</p> <p>​			①、<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p> <p>​			② 、<strong>Collections.synchronizedList(List list)：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//使用Collections.synchronizedList(List list)方法实现线程安全</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token operator">=</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​			③、<strong>CopyOnWriteArrayList：<strong>写时加锁，使用了一种叫</strong>写时复制</strong>的方法；读操作是可以不用加锁的</p> <p>​</p> <p><strong>12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？</strong></p> <p><strong>①、普通for循环遍历List删除指定元素</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> 
       list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>② 、迭代遍历,用list.remove(i)方法删除元素</strong></p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Integer</span> value <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>③、foreach遍历List删除元素</strong></p> <div class="language-JAVA line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>**fail—fast：**快速失败</p> <p>​		当异常产生时，直接抛出异常，程序终止;</p> <p>​		fail-fast只要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。这里要注意的这里说的结构被改变,是例如插入和删除这种操作,只是改变集合里的值的话并不会抛出异常。</p> <p>**fail—safe：**安全失败</p> <p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p> <p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p> <p>缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p> <p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p> <p><strong>13、详细介绍HashMap。</strong></p> <p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p> <p>参考：https://www.jianshu.com/p/9fe4cb316c05</p> <p><strong>数据结构：</strong></p> <p>​		HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p> <p><strong>扩容情况：</strong></p> <p>​		默认的负载因子是0.75，表示的是，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p> <p>​		【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p> <p>​		【2】重新对原数组中的Entry对象进行哈希运算，以确定他们各自在新数组中的新位置。</p> <p><strong>put操作步骤：</strong></p> <p>​	1、判断数组是否为空，为空进行初始化;</p> <p>​	2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p> <p>​	3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p> <p>​	4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p> <p>​	5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p> <p>​	6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p> <p>​	7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p> <p><strong>哈希函数：</strong></p> <p>​	 hash函数是先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞。</p> <p><strong>容量为什么始终都是2^N：</strong></p> <p>​		为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来⼤概40亿的映射空间，只要哈希函数映射得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。但问题是⼀个40亿⻓度的数组，内存是放不下的。所以这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“  (n - 1) &amp; hash ”。（n代表数组⻓度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p> <p><strong>JDK1.7与1.8的区别：</strong></p> <p><strong>JDK1.7 HashMap：</strong></p> <p>​		底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p> <p><strong>JDK1.8 HashMap：</strong></p> <p>​		HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据；当链表⻓度⼤于阈值（默认为 8），数组的⻓度大于 64时，将链表转化为红⿊树，以减少搜索时间</p> <p><strong>14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别</strong></p> <p>​		可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p> <p><strong>ConcurrentHashMap的底层实现：</strong></p> <p>​		<strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p> <p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&amp;fm=26&amp;gp=0.jpg" alt=""></p> <p>​		<strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p> <p><strong>15、正则表达式会写吗？</strong></p> <p>参考：https://blog.csdn.net/qq_39331713/article/details/82871510</p> <p>​		正则通过一些特定的符号与数字来表示一串字符，其中有：元字符、重复限定符、分组、转义、条件或、区间；</p> <p><strong>16、设计模式了解吗？</strong></p> <p>单例模式、工厂模式、代理模式</p> <p><strong>17、linux指令知道哪些？</strong></p> <p>文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限</p> <p>进程管理：ps显示进程信息、kill杀死进程</p> <p>系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况</p> <p>网络通讯：ping测试网络连通性、netstat显示网络相关信息</p> <p><strong>18、JVM相关</strong></p> <p><strong>1、JVM运行时内存划分？</strong></p> <p>**JVM运行时数据区域：**堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p> <p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3099290709,1184193923&amp;fm=26&amp;gp=0.jpg" alt=""></p> <p><strong>Heap(堆)：</strong></p> <p>​		对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；</p> <p>​		堆细分：新生代、老年代，对于新生代又分为：Eden区和Surviver1和Surviver2区；</p> <p><strong>方法区：</strong></p> <p>​		对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p> <p><strong>虚拟机栈：</strong></p> <p>​		虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p> <ul><li><p><strong>局部变量表：<strong>局部变量表是一组变量值存储空间，用来存放</strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。局部变量表的容量是以变量槽（variable slot）为最小的单位。Java虚拟机没有明确规定一个slot所占的空间大小。只是导向性的说了每一个slot能存放8种基本数据类型中的一种(long 和double这种64位的需要两个slot)；</p></li> <li><p><strong>操作数栈：<strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种</strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p></li> <li><p><strong>动态链接：<strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在</strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p></li> <li><p>**返回地址（returnAddress）：**类型（指向了一条字节码指令的地址）</p></li></ul> <p><strong>本地方法栈：</strong></p> <p>​		本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p> <p><strong>PC程序计数器：</strong></p> <p>​		PC，指的是存放下一条指令的位置的这么一个区域。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，一个线程执行完了，接下来CPU切换到另一个线程去执行，另外一个线程执行完再切回到之前的线程，这时需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p> <p><strong>2、堆内存分配策略</strong></p> <p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3784749479,768026745&amp;fm=26&amp;gp=0.jpg" alt=""></p> <ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p></li> <li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li> <li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p></li> <li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li></ul> <p><strong>3、Full GC触发条件</strong></p> <p>​	每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小，则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC</p> <p><strong>4、如何判断对象是否存活？回收对象的两次标记过程。</strong></p> <p><strong>引用计数法：</strong></p> <p>​		给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p> <p>​	优点：实现简单，判定效率也很高</p> <p>​	缺点：他很难解决对象之间相互循环引用的问题。</p> <p><strong>对象可达性：</strong></p> <p>​		通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p> <p><strong>两次标记过程：</strong></p> <p>​		对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p> <p><strong>5、垃圾回收算法以及垃圾回收器介绍，尤其是G1和CMS的优缺点</strong></p> <p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p> <p><strong>复制算法：</strong></p> <p>​		将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p> <p>​		优点：实现简单，内存效率高，不易产生碎片</p> <p>​		缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p> <p><strong>标记清除：</strong></p> <p>​		标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p> <p>​		缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，可能发生大对象不能找到可利用空间的问题。</p> <p><strong>标记整理：</strong></p> <p>​		标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p> <p><strong>分代收集：</strong></p> <p>​		根据各个年代的特点选择合适的垃圾收集算法。</p> <p>​		新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p> <p>​		老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p> <p><strong>垃圾收集器：Serial、Parnew、parallel Scavenge、Serial old 、Parnew old、CMS、G1</strong></p> <p><strong>Serial：</strong></p> <p>​		Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p> <p><strong>Parnew：</strong></p> <p>​		ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p> <p><strong>parallel Scavenge：</strong></p> <p>​		Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p> <p><strong>Serial old：</strong></p> <p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p> <ul><li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p></li> <li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p></li></ul> <p><strong>parallel old：</strong></p> <p>​		Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p> <p>**CMS：**重要</p> <p>​		CMS收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p> <p>​		**初始标记：**只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p> <p>​		**并发标记：**进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p> <p>​		**重新标记：**为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p> <p>​		**并发清除：**清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p> <p>​		**优点：**并发收集、低停顿</p> <p>​		**缺点：**对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p> <p>**G1：**重要</p> <p>​		是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p> <p>​		【1】基于标记-整理算法，不产生内存碎片。</p> <p>​		【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p> <p>​		G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p> <p><strong>6、创建一个对象的步骤</strong></p> <p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p> <p><strong>①类加载检查：</strong></p> <p>​		虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p> <p><strong>②分配内存：</strong></p> <p>​		 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p> <p><strong>③初始化零值：</strong></p> <p>​		 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p> <p><strong>④设置对象头：</strong></p> <p>​		初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p> <p><strong>⑤执⾏ init ⽅法：</strong></p> <p>​		在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏  <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。</init></init></p> <p><strong>7、详细介绍类加载过程</strong></p> <p><strong>过程：加载、验证、准备、解析、初始化</strong></p> <p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2723431542,2953407468&amp;fm=26&amp;gp=0.jpg" alt=""></p> <p><strong>加载阶段：</strong></p> <p>​		1.通过一个类的全限定名来获取定义此类的二进制字节流。</p> <p>​		2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p> <p>​		3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。</p> <p><strong>验证阶段：</strong></p> <p>​		1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p> <p>​		2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p> <p>​		3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p> <p>​		4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p> <p><strong>准备阶段：</strong></p> <p>​		准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值</p> <p><strong>解析阶段：</strong></p> <p>​		解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p> <p><strong>初始化阶段：</strong></p> <p>​		初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p> <p><strong>8、双亲委派机制，使用这个机制的好处？如何破坏？</strong></p> <p>​		每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的  loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器  BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器  BootstrapClassLoader 作为⽗类加载器。</p> <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1595226330267&amp;di=5597292eb6bf5505abbec489fd54dacd&amp;imgtype=0&amp;src=http%3A%2F%2Fpics4.baidu.com%2Ffeed%2Fca1349540923dd54fb52494e811379d89c824890.jpeg%3Ftoken%3Dc280035219d435ec0f1c3a3a0a071101" alt=""></p> <p><strong>使用好处：</strong></p> <p>​		此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为  java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p> <p><strong>破坏双亲委派机制：</strong></p> <p>​		可以⾃⼰定义⼀个类加载器，重写loadClass方法；</p> <p><strong>9、了解下tomcat的类加载机制</strong></p> <p><strong>步骤：</strong></p> <ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li> <li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li> <li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li> <li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li> <li>加载依然失败，才使用 AppClassLoader 继续加载。</li> <li>都没有加载成功的话，抛出异常。</li></ol> <p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p> <p><strong>10、JVM性能调优，常用命令，以及工具</strong></p> <p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p> <p>**常用命令：**jps、jinfo、jstat、jstack、jmap</p> <p><strong>jps：查看java进程及相关信息</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>jps <span class="token operator">-</span>l 输出jar包路径，类全名
jps <span class="token operator">-</span>m 输出main参数
jps <span class="token operator">-</span>v 输出<span class="token constant">JVM</span>参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>jinfo：查看JVM参数</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>jinfo <span class="token number">11666</span>
jinfo <span class="token operator">-</span>flags <span class="token number">11666</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>命令格式：
jstat <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token constant">LVMID</span> <span class="token punctuation">[</span>interval<span class="token punctuation">]</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
其中<span class="token constant">LVMID</span>是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）

option参数解释：
<span class="token operator">-</span><span class="token keyword">class</span> <span class="token keyword">class</span> loader的行为统计
<span class="token operator">-</span>compiler <span class="token class-name">HotSpt</span> <span class="token constant">JIT</span>编译器行为统计
<span class="token operator">-</span>gc 垃圾回收堆的行为统计
<span class="token operator">-</span>gccapacity 各个垃圾回收代容量<span class="token punctuation">(</span>young<span class="token punctuation">,</span>old<span class="token punctuation">,</span>perm<span class="token punctuation">)</span>和他们相应的空间统计
<span class="token operator">-</span>gcutil 垃圾回收统计概述
<span class="token operator">-</span>gccause 垃圾收集统计概述（同<span class="token operator">-</span>gcutil），附加最近两次垃圾回收事件的原因
<span class="token operator">-</span>gcnew 新生代行为统计
<span class="token operator">-</span>gcnewcapacity 新生代与其相应的内存空间的统计
<span class="token operator">-</span>gcold 年老代和永生代行为统计
<span class="token operator">-</span>gcoldcapacity 年老代行为统计
<span class="token operator">-</span>gcpermcapacity 永生代行为统计
<span class="token operator">-</span>printcompilation <span class="token class-name">HotSpot</span>编译方法统计
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>命令格式：
jstack <span class="token punctuation">[</span><span class="token operator">-</span>l<span class="token punctuation">]</span> <span class="token generics"><span class="token punctuation">&lt;</span>pid<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接运行中的进程<span class="token punctuation">)</span>
jstack <span class="token operator">-</span><span class="token class-name">F</span> <span class="token punctuation">[</span><span class="token operator">-</span>m<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>l<span class="token punctuation">]</span> <span class="token generics"><span class="token punctuation">&lt;</span>pid<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接挂起的进程<span class="token punctuation">)</span>
jstack <span class="token punctuation">[</span><span class="token operator">-</span>m<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>l<span class="token punctuation">]</span> <span class="token generics"><span class="token punctuation">&lt;</span>executable<span class="token punctuation">&gt;</span></span> <span class="token generics"><span class="token punctuation">&lt;</span>core<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接core文件<span class="token punctuation">)</span>
jstack <span class="token punctuation">[</span><span class="token operator">-</span>m<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>l<span class="token punctuation">]</span> <span class="token punctuation">[</span>server_id@<span class="token punctuation">]</span><span class="token generics"><span class="token punctuation">&lt;</span>remote server IP or hostname<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接远程debug服务器<span class="token punctuation">)</span>

option参数解释：
<span class="token operator">-</span><span class="token class-name">F</span> 当使用jstack <span class="token generics"><span class="token punctuation">&lt;</span>pid<span class="token punctuation">&gt;</span></span>无响应时，强制输出线程堆栈。
<span class="token operator">-</span>m 同时输出java和本地堆栈<span class="token punctuation">(</span>混合模式<span class="token punctuation">)</span>
<span class="token operator">-</span>l 额外显示锁信息
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>jmap：可以用来查看内存信息</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>命令格式：
jmap <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token generics"><span class="token punctuation">&lt;</span>pid<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接正在执行的进程<span class="token punctuation">)</span>
jmap <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token operator">&lt;</span>executable <span class="token generics"><span class="token punctuation">&lt;</span>core<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>连接一个core文件<span class="token punctuation">)</span>
jmap <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token punctuation">[</span>server_id@<span class="token punctuation">]</span><span class="token generics"><span class="token punctuation">&lt;</span>remote server IP or hostname<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>链接远程服务器<span class="token punctuation">)</span>

option参数解释：
<span class="token generics"><span class="token punctuation">&lt;</span>none<span class="token punctuation">&gt;</span></span> <span class="token keyword">to</span> <span class="token namespace">print</span> same info as <span class="token class-name">Solaris</span> pmap
<span class="token operator">-</span>heap 打印java heap摘要
<span class="token operator">-</span>histo<span class="token punctuation">[</span><span class="token operator">:</span>live<span class="token punctuation">]</span> 打印堆中的 java对象统计信息
<span class="token operator">-</span>clstats 打印类加载器统计信息
<span class="token operator">-</span>finalizerinfo 打印在f<span class="token operator">-</span>queue中等待执行finalizer方法的对象
<span class="token operator">-</span>dump<span class="token operator">:</span><span class="token operator">&lt;</span>dump<span class="token operator">-</span>options<span class="token operator">&gt;</span> 生成java堆的dump文件
　　　　　　dump<span class="token operator">-</span>options<span class="token operator">:</span>
　　　　　　live 只转储存活的对象，如果没有指定则转储所有对象
　　　　　　format<span class="token operator">=</span>b 二进制格式
　　　　　　file<span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>file<span class="token punctuation">&gt;</span></span> 转储文件到 <span class="token generics"><span class="token punctuation">&lt;</span>file<span class="token punctuation">&gt;</span></span>
<span class="token operator">-</span><span class="token class-name">F</span> 强制选项
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>11、JVM性能调优，常用命令，以及工具</strong></p> <p><strong>公平锁和非公平锁</strong>
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。</p> <p>公平锁的好处是等待锁的线程不会饿死，但是整体效率相对低一些；非公平锁的好处是整体效率相对高一些，但是有些线程可能会饿死或者说很早就在等待锁，但要等很久才会获得锁。其中的原因是公平锁是严格按照请求所的顺序来排队获得锁的，而非公平锁时可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在等待队列的线程则不会被唤醒。</p> <p>公平锁可以使用new ReentrantLock(true)实现。</p> <p><strong>自旋锁</strong>
Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态装换需要耗费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</p> <p>虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间取挂起和恢复现场并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p> <p>自旋等待不能代替阻塞。自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会拜拜浪费处理器资源。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。</p> <p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK6中已经变为默认开启，并且引入了自适应的自旋锁。自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p> <p>自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。</p> <blockquote><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p></blockquote> <p><strong>锁消除</strong>
锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据是来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而能被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就无需进行。</p> <p>来看这样一个方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">concatString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以知道StringBuffer 的append方法定义如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">StringBuffer</span> sb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>也就是说在concatString()方法中涉及了同步操作。但是可以观察到sb对象它的作用域被限制在方法的内部，也就是sb对象不会“逃逸”出去，其他线程无法访问。因此，虽然这里有锁，但是可以被安全的消除，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p> <p><strong>锁粗化</strong>
原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁禁止，那等待的线程也能尽快拿到锁。大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。</p> <p>举个案例，类似锁消除的concatString()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。</p> <p><strong>可重入锁</strong>
可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p> <p>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。可重入锁最大的作用是避免死锁。</p> <p><strong>类锁和对象锁</strong>
类锁：在方法上加上static synchronized的锁，或者synchronized(xxx.class)的锁。如下代码中的method1和method2：</p> <p>对象锁：参考method4, method5,method6.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockStrategy</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> object1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">LockStrategy</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method5</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method6</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>下面做一道习题来加深一下对对象锁和类锁的理解.
有一个类这样定义:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedTest</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>那么，有SynchronizedTest的两个实例a和b，对于一下的几个选项有哪些能被一个以上的线程同时访问呢？
A. a.method1() vs. a.method2()
B. a.method1() vs. b.method1()
C. a.method3() vs. b.method4()
D. a.method3() vs. b.method3()
E. a.method1() vs. a.method3()
答案是什么呢？BE</p> <p>##<strong>偏向锁、轻量级锁和重量级锁</strong>
synchronized的偏向锁、轻量级锁以及重量级锁是通过Java对象头实现的。博主在<a href="http://blog.csdn.net/u013256816/article/details/51008443" target="_blank" rel="noopener noreferrer">Java对象大小内幕浅析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中提到了Java对象的内存布局分为：对象头、实例数据和对齐填充，而对象头又可以分为&quot;Mark Word&quot;和类型指针klass。&quot;Mark Word&quot;是关键，默认情况下，其存储对象的HashCode、分代年龄和锁标记位。</p> <p>这里说的都是以HotSpot虚拟机为基准的。首先来看一下&quot;Mark Word&quot;的内容：</p> <table><thead><tr><th>锁状态</th> <th>存储内容</th> <th>标志位</th></tr></thead> <tbody><tr><td>无锁</td> <td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td> <td>01</td></tr> <tr><td>轻量级</td> <td>指向栈中锁记录的指针</td> <td>00</td></tr> <tr><td>重量级</td> <td>指向互斥量（重量级锁）的指针</td> <td>10</td></tr> <tr><td>GC标记</td> <td>（空）</td> <td>11</td></tr> <tr><td>偏向锁</td> <td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td> <td>01</td></tr></tbody></table> <p>注意到这里的无锁和偏向锁在&quot;Mark Word&quot;的倒数第三bit中分别采用0和1标记。</p> <p>偏向锁是JDK6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。</p> <p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p> <p>当锁对象第一次被线程获取的时候，线程使用CAS操作把这个锁的线程ID记录再对象Mark Word之中，同时置偏向标志位1。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。</p> <p>如果线程使用CAS操作时失败则表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权。当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁（涉及Monitor Record，Lock Record相关操作，这里不展开），同时被撤销偏向锁的线程继续往下执行同步代码。</p> <p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p> <p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录(Lock Record)的空间，并将对象头中的Mard Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果自旋失败则锁会膨胀成重量级锁。如果自旋成功则依然处于轻量级锁的状态。</p> <p>轻量级锁的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中赋值的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了，如果替换失败，就说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p> <p>轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。</p> <p>整个synchronized锁流程如下：</p> <ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li> <li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li> <li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li> <li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li> <li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li> <li>如果自旋成功则依然处于轻量级状态。</li> <li>如果自旋失败，则升级为重量级锁。</li></ol> <p><strong>悲观锁和乐观锁</strong>
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）</p> <p><strong>共享锁和排它锁</strong>
共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。</p> <p><strong>读写锁</strong>
读写锁是一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。具体使用方法这里不展开。</p> <p><strong>互斥锁</strong>
所谓互斥锁就是指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。</p> <p><strong>无锁</strong>
要保证现场安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p> <ol><li>无状态编程。无状态代码有一些共同的特征：不依赖于存储在对上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。</li> <li>线程本地存储。可以参考ThreadLocal</li> <li>volatile</li> <li>CAS</li> <li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ol> <p><strong>分段锁</strong>
ConcurrentHashMap中采用了分段锁</p> <p><strong>闭锁</strong>
闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。CountDownLatch就是一种灵活的闭锁实现。</p> <p><strong>死锁</strong>
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足一下4个条件：</p> <ul><li>互斥条件：一个资源每次只能被一个进程使用。</li> <li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li> <li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li> <li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul> <p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁。</p> <p><strong>活锁</strong>
LiveLock是一种形式活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发送在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">4/15/2023, 1:36:11 AM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-b57cc07c data-v-7dd95ae2></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><canvas id="vuepress-canvas-cursor"></canvas><canvas id="vuepress-canvas-ribbon"></canvas></div></div>
    <script src="/assets/js/app.05e9a5df.js" defer></script><script src="/assets/js/3.c925c384.js" defer></script><script src="/assets/js/1.9975a5e7.js" defer></script><script src="/assets/js/29.59e6b149.js" defer></script>
  </body>
</html>
