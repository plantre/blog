(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{431:function(a,t,s){"use strict";s.r(t);var r=s(2),e=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("OS是管理计算机硬件与软件资源的程序，是计算机的基石")]),a._v(" "),t("h2",{attrs:{id:"进程管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程管理"}},[a._v("#")]),a._v(" 进程管理")]),a._v(" "),t("h3",{attrs:{id:"系统调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统调用"}},[a._v("#")]),a._v(" 系统调用")]),a._v(" "),t("h4",{attrs:{id:"用户态-user-mode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户态-user-mode"}},[a._v("#")]),a._v(" 用户态(user mode)")]),a._v(" "),t("h4",{attrs:{id:"核心态-kernel-mode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心态-kernel-mode"}},[a._v("#")]),a._v(" 核心态(kernel mode)")]),a._v(" "),t("h3",{attrs:{id:"状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[a._v("#")]),a._v(" 状态")]),a._v(" "),t("h4",{attrs:{id:"创建状态-new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建状态-new"}},[a._v("#")]),a._v(" 创建状态(new)")]),a._v(" "),t("h4",{attrs:{id:"就绪状态-ready"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#就绪状态-ready"}},[a._v("#")]),a._v(" 就绪状态(ready)")]),a._v(" "),t("p",[a._v("一旦得到处理器资源(处理器分配的时间片)即可运行")]),a._v(" "),t("h4",{attrs:{id:"运行状态-running"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行状态-running"}},[a._v("#")]),a._v(" 运行状态(running)")]),a._v(" "),t("h4",{attrs:{id:"阻塞状态-waiting"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阻塞状态-waiting"}},[a._v("#")]),a._v(" 阻塞状态(waiting)")]),a._v(" "),t("p",[a._v("进程正在等待某一事件而暂停运行，即使处理器空闲，该进程也不能运行。")]),a._v(" "),t("h4",{attrs:{id:"结束状态-terminated"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结束状态-terminated"}},[a._v("#")]),a._v(" 结束状态(terminated)")]),a._v(" "),t("h3",{attrs:{id:"通信方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信方式"}},[a._v("#")]),a._v(" 通信方式")]),a._v(" "),t("h4",{attrs:{id:"管道-匿名管道-pipes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道-匿名管道-pipes"}},[a._v("#")]),a._v(" 管道/匿名管道(Pipes)")]),a._v(" "),t("p",[a._v("具有亲缘关系的父子进程间或者兄弟进程之间，无名管道：只存在于内存中的文件；")]),a._v(" "),t("h4",{attrs:{id:"有名管道-names-pipes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有名管道-names-pipes"}},[a._v("#")]),a._v(" 有名管道(Names Pipes)")]),a._v(" "),t("p",[a._v("有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信，命名管道：存在于实际的磁盘介质或者文件系统")]),a._v(" "),t("h4",{attrs:{id:"信号-signal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号-signal"}},[a._v("#")]),a._v(" 信号(Signal)")]),a._v(" "),t("p",[a._v("用于通知接收进程某个事件已经发生")]),a._v(" "),t("h4",{attrs:{id:"消息队列-message-queuing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列-message-queuing"}},[a._v("#")]),a._v(" 消息队列(Message Queuing)")]),a._v(" "),t("p",[a._v("消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列，克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺")]),a._v(" "),t("h4",{attrs:{id:"信号量-semaphores"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号量-semaphores"}},[a._v("#")]),a._v(" 信号量(Semaphores)")]),a._v(" "),t("p",[a._v("信号量是一个计数器，用于多进程对共享数据的访问")]),a._v(" "),t("h4",{attrs:{id:"共享内存-shared-memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享内存-shared-memory"}},[a._v("#")]),a._v(" 共享内存(Shared memory)")]),a._v(" "),t("p",[a._v("最有用的进程间通信方式")]),a._v(" "),t("h4",{attrs:{id:"套接字-sockets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#套接字-sockets"}},[a._v("#")]),a._v(" 套接字(Sockets)")]),a._v(" "),t("p",[a._v("不同主机之间的进程进行双向通信")]),a._v(" "),t("h3",{attrs:{id:"同步方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步方式"}},[a._v("#")]),a._v(" 同步方式")]),a._v(" "),t("h4",{attrs:{id:"互斥量-mutex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#互斥量-mutex"}},[a._v("#")]),a._v(" 互斥量(Mutex)")]),a._v(" "),t("p",[a._v("采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，如 Java 中的 synchronized 关键词和各种 Lock")]),a._v(" "),t("h4",{attrs:{id:"信号量-semphares"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号量-semphares"}},[a._v("#")]),a._v(" 信号量(Semphares)")]),a._v(" "),t("p",[a._v("允许同一时刻多个线程访问同一资源")]),a._v(" "),t("h4",{attrs:{id:"事件-event"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件-event"}},[a._v("#")]),a._v(" 事件(Event)")]),a._v(" "),t("p",[a._v("通知操作的方式来保持多线程同步")]),a._v(" "),t("h3",{attrs:{id:"调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[a._v("#")]),a._v(" 调度算法")]),a._v(" "),t("h4",{attrs:{id:"先到先服务-fcfs-调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先到先服务-fcfs-调度算法"}},[a._v("#")]),a._v(" 先到先服务(FCFS)调度算法")]),a._v(" "),t("h4",{attrs:{id:"短作业优先-sjf-的调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#短作业优先-sjf-的调度算法"}},[a._v("#")]),a._v(" 短作业优先(SJF)的调度算法")]),a._v(" "),t("h4",{attrs:{id:"时间片轮转调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间片轮转调度算法"}},[a._v("#")]),a._v(" 时间片轮转调度算法")]),a._v(" "),t("p",[a._v("最古老，最简单，最公平且使用最广的算法")]),a._v(" "),t("h4",{attrs:{id:"多级反馈队列调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多级反馈队列调度算法"}},[a._v("#")]),a._v(" 多级反馈队列调度算法")]),a._v(" "),t("p",[a._v("既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法")]),a._v(" "),t("h4",{attrs:{id:"优先级调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级调度"}},[a._v("#")]),a._v(" 优先级调度")]),a._v(" "),t("p",[a._v("具有相同优先级的进程以 FCFS 方式执行")]),a._v(" "),t("h3",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),t("h4",{attrs:{id:"互斥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#互斥"}},[a._v("#")]),a._v(" 互斥")]),a._v(" "),t("p",[a._v("资源一次只有一个进程可以使用")]),a._v(" "),t("h4",{attrs:{id:"占有并等待"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#占有并等待"}},[a._v("#")]),a._v(" 占有并等待")]),a._v(" "),t("p",[a._v("一个进程至少应该占有一个资源，并等待另一被其他进程所占有的资源")]),a._v(" "),t("h4",{attrs:{id:"非抢占"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非抢占"}},[a._v("#")]),a._v(" 非抢占")]),a._v(" "),t("p",[a._v("资源不能被抢占，")]),a._v(" "),t("h4",{attrs:{id:"循环等待"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环等待"}},[a._v("#")]),a._v(" 循环等待")]),a._v(" "),t("p",[a._v("Pn 等待的资源被 P0 占有")]),a._v(" "),t("p",[a._v("四大条件仅仅是产生死锁的必要条件")]),a._v(" "),t("h3",{attrs:{id:"解决死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决死锁"}},[a._v("#")]),a._v(" 解决死锁")]),a._v(" "),t("h4",{attrs:{id:"预防-考虑破坏第二个条件和第四个条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预防-考虑破坏第二个条件和第四个条件"}},[a._v("#")]),a._v(" 预防，考虑破坏第二个条件和第四个条件")]),a._v(" "),t("h5",{attrs:{id:"静态分配策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态分配策略"}},[a._v("#")]),a._v(" 静态分配策略")]),a._v(" "),t("p",[a._v("一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行")]),a._v(" "),t("h5",{attrs:{id:"层次分配策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#层次分配策略"}},[a._v("#")]),a._v(" 层次分配策略")]),a._v(" "),t("p",[a._v("一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源")]),a._v(" "),t("h3",{attrs:{id:"避免-dijkstra-的银行家算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#避免-dijkstra-的银行家算法"}},[a._v("#")]),a._v(" 避免（ Dijkstra 的银行家算法）")]),a._v(" "),t("p",[a._v("将系统的状态分为 安全状态 和 不安全状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请")]),a._v(" "),t("h3",{attrs:{id:"检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#检测"}},[a._v("#")]),a._v(" 检测，")]),a._v(" "),t("p",[a._v("进程-资源分配图中无环路，则此时系统没有发生死锁")]),a._v(" "),t("p",[a._v("进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁")]),a._v(" "),t("p",[a._v("进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁")]),a._v(" "),t("h3",{attrs:{id:"解除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解除"}},[a._v("#")]),a._v(" 解除")]),a._v(" "),t("p",[a._v("立即结束所有进程的执行，重新启动操作系统")]),a._v(" "),t("p",[a._v("撤销涉及死锁的所有进程，解除死锁后继续运行")]),a._v(" "),t("p",[a._v("逐个撤销涉及死锁的进程，回收其资源直至死锁解除")]),a._v(" "),t("p",[a._v("抢占资源")]),a._v(" "),t("h2",{attrs:{id:"内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),t("h3",{attrs:{id:"连续分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连续分配"}},[a._v("#")]),a._v(" 连续分配")]),a._v(" "),t("h4",{attrs:{id:"块式管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块式管理"}},[a._v("#")]),a._v(" 块式管理")]),a._v(" "),t("h3",{attrs:{id:"非连续分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非连续分配"}},[a._v("#")]),a._v(" 非连续分配")]),a._v(" "),t("p",[a._v("页是物理单位，段是逻辑单位，分页机制和分段机制都是为了提高内存利用率，减少内存碎片，页和段都是离散存储的，页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序")]),a._v(" "),t("h4",{attrs:{id:"页式管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页式管理"}},[a._v("#")]),a._v(" 页式管理")]),a._v(" "),t("h5",{attrs:{id:"主存分为大小相等且固定的一页一页的形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主存分为大小相等且固定的一页一页的形式"}},[a._v("#")]),a._v(" 主存分为大小相等且固定的一页一页的形式")]),a._v(" "),t("h5",{attrs:{id:"快表-tlb是mmu的一部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快表-tlb是mmu的一部分"}},[a._v("#")]),a._v(" 快表（TLB是MMU的一部分）")]),a._v(" "),t("p",[a._v("根据虚拟地址中的页号查快表；")]),a._v(" "),t("p",[a._v("如果该页在快表中，直接从快表中读取相应的物理地址；")]),a._v(" "),t("p",[a._v("如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；")]),a._v(" "),t("p",[a._v("当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页")]),a._v(" "),t("h5",{attrs:{id:"多级页表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多级页表"}},[a._v("#")]),a._v(" 多级页表")]),a._v(" "),t("h4",{attrs:{id:"段式管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#段式管理"}},[a._v("#")]),a._v(" 段式管理")]),a._v(" "),t("p",[a._v("把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息")]),a._v(" "),t("h4",{attrs:{id:"段页式管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#段页式管理"}},[a._v("#")]),a._v(" 段页式管理")]),a._v(" "),t("p",[a._v("把主存先分成若干段，每个段又分成若干页")]),a._v(" "),t("h3",{attrs:{id:"虚拟内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[a._v("#")]),a._v(" 虚拟内存")]),a._v(" "),t("p",[a._v("定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间")]),a._v(" "),t("h4",{attrs:{id:"页面置换算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[a._v("#")]),a._v(" 页面置换算法")]),a._v(" "),t("h5",{attrs:{id:"fifo-first-in-first-out-页面置换算法-先进先出页面置换算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fifo-first-in-first-out-页面置换算法-先进先出页面置换算法"}},[a._v("#")]),a._v(" FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）")]),a._v(" "),t("h5",{attrs:{id:"opt-页面置换算法-最佳页面置换算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#opt-页面置换算法-最佳页面置换算法"}},[a._v("#")]),a._v(" OPT 页面置换算法（最佳页面置换算法）")]),a._v(" "),t("h5",{attrs:{id:"lru-least-recently-used-页面置换算法-最近最久未使用页面置换算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-least-recently-used-页面置换算法-最近最久未使用页面置换算法"}},[a._v("#")]),a._v(" LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）")]),a._v(" "),t("h5",{attrs:{id:"lfu-least-frequently-used-页面置换算法-最少使用页面置换算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lfu-least-frequently-used-页面置换算法-最少使用页面置换算法"}},[a._v("#")]),a._v(" LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）")]),a._v(" "),t("h2",{attrs:{id:"文件管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件管理"}},[a._v("#")]),a._v(" 文件管理")]),a._v(" "),t("h2",{attrs:{id:"io管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io管理"}},[a._v("#")]),a._v(" IO管理")])])}),[],!1,null,null,null);t.default=e.exports}}]);