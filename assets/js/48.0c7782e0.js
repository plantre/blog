(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{471:function(v,_,t){"use strict";t.r(_);var s=t(2),p=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("strong",[v._v("1、为什么使用Redis")])]),v._v(" "),_("p",[v._v("​\t\t速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；")]),v._v(" "),_("p",[v._v("​\t\t与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。")]),v._v(" "),_("p",[v._v("​")]),v._v(" "),_("p",[_("strong",[v._v("2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？")])]),v._v(" "),_("p",[v._v("​\t\t分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；")]),v._v(" "),_("p",[v._v("​\t\t本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。")]),v._v(" "),_("p",[_("strong",[v._v("本地缓存设计：")])]),v._v(" "),_("p",[v._v("​\t\t以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。")]),v._v(" "),_("p",[_("strong",[v._v("解决缓存过期：")])]),v._v(" "),_("p",[v._v("​\t1、将缓存过期时间调为永久")]),v._v(" "),_("p",[v._v("​\t2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。")]),v._v(" "),_("p",[_("strong",[v._v("解决内存溢出：")])]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("第一步")]),v._v("，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)")]),v._v(" "),_("p",[_("strong",[v._v("第二步")]),v._v("，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。")]),v._v(" "),_("p",[_("strong",[v._v("第三步")]),v._v("，对代码进行走查和分析，找出可能发生内存溢出的位置。")]),v._v(" "),_("p",[_("strong",[v._v("3、redis和"),_("em",[v._v("Mem")]),v._v("cached的区别")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("redis")]),v._v(" "),_("th",[v._v("Memcached")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("内存高速数据库")]),v._v(" "),_("td",[v._v("高性能分布式内存缓存数据库，可缓存图片、视频")])]),v._v(" "),_("tr",[_("td",[v._v("支持hash、list、set、zset、string结构")]),v._v(" "),_("td",[v._v("只支持key-value结构")])]),v._v(" "),_("tr",[_("td",[v._v("将大部分数据放到内存")]),v._v(" "),_("td",[v._v("全部数据放到内存中")])]),v._v(" "),_("tr",[_("td",[v._v("支持持久化、主从复制备份")]),v._v(" "),_("td",[v._v("不支持数据持久化及数据备份")])]),v._v(" "),_("tr",[_("td",[v._v("数据丢失可通过AOF恢复")]),v._v(" "),_("td",[v._v("挂掉后，数据不可恢复")])])])]),v._v(" "),_("p",[_("strong",[v._v("使用场景：")])]),v._v(" "),_("p",[v._v("​\t1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。\n​\t2、如果简单的key/value 存储应该选择memcached。")]),v._v(" "),_("p",[_("strong",[v._v("4、redis常用数据结构和使用场景")])]),v._v(" "),_("p",[v._v("Redis主要有5种数据类型，包括String，List，Set，Zset，Hash")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("类型")]),v._v(" "),_("th",[v._v("存储值")]),v._v(" "),_("th",[v._v("应用场景")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("String")]),v._v(" "),_("td",[v._v("字符串、整数、浮点数")]),v._v(" "),_("td",[v._v("简单的键值对缓存")])]),v._v(" "),_("tr",[_("td",[v._v("List")]),v._v(" "),_("td",[v._v("列表")]),v._v(" "),_("td",[v._v("存储列表型数据结构，例如：评论列表、商品列表")])]),v._v(" "),_("tr",[_("td",[v._v("Set")]),v._v(" "),_("td",[v._v("无序集合")]),v._v(" "),_("td",[v._v("适合交集、并集、查集操作，例如朋友关系")])]),v._v(" "),_("tr",[_("td",[v._v("Zset")]),v._v(" "),_("td",[v._v("有序集合")]),v._v(" "),_("td",[v._v("去重后排序，适合排名场景")])]),v._v(" "),_("tr",[_("td",[v._v("Hash")]),v._v(" "),_("td",[v._v("哈希")]),v._v(" "),_("td",[v._v("结构化数据，比如存储对象")])])])]),v._v(" "),_("p",[_("strong",[v._v("Redis的应用场景：")])]),v._v(" "),_("p",[_("strong",[v._v("计数器")])]),v._v(" "),_("p",[v._v("​\t\t可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。")]),v._v(" "),_("p",[_("strong",[v._v("缓存")])]),v._v(" "),_("p",[v._v("​\t\t将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。")]),v._v(" "),_("p",[_("strong",[v._v("会话缓存")])]),v._v(" "),_("p",[v._v("​\t\t可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。")]),v._v(" "),_("p",[_("strong",[v._v("其它")])]),v._v(" "),_("p",[v._v("​\t\tSet 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。")]),v._v(" "),_("p",[_("strong",[v._v("5、Zset底层实现？跳表搜索插入删除过程？")])]),v._v(" "),_("p",[v._v("​\t\t跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度")]),v._v(" "),_("p",[v._v("​\t\tZset数据量少的时候使用压缩链表ziplist实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。")]),v._v(" "),_("p",[v._v("​\t\t 数据量大的时候使用跳跃列表skiplist和哈希表hash_map结合实现，查找删除插入的时间复杂度都是O(logN)")]),v._v(" "),_("p",[_("strong",[v._v("搜索")])]),v._v(" "),_("p",[v._v("​\t\t跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 "),_("em",[v._v("O(logN)，最坏 O(N) 。")])]),v._v(" "),_("p",[_("strong",[v._v("插入")])]),v._v(" "),_("p",[v._v("之前就说了，之所以选用链表作为底层结构支持，也是为了高效地动态增删。单链表在知道删除的节点是谁时，时间复杂度为O(1)，因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。")]),v._v(" "),_("p",[_("strong",[v._v("删除")])]),v._v(" "),_("p",[v._v("删除的节点要分两种情况，如果该节点还在索引中，那删除时不仅要删除单链表中的节点，还要删除索引中的节点；另一种情况是删除的节点只在链表中，不在索引中，那只需要删除链表中的节点即可。但针对单链表来说，删除时都需要拿到前驱节点才可改变引用关系从而删除目标节点。")]),v._v(" "),_("p",[_("strong",[v._v("6、redis过期淘汰策略")])]),v._v(" "),_("p",[_("strong",[v._v("1）全局的键空间选择性移除")])]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("noeviction")]),v._v("：当内存不足以容纳新写入数据时，新写入操作会报错。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("allkeys-lru")]),v._v("：在键空间中，移除最近最少使用的key。（这个是最常用的）")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("allkeys-random")]),v._v("：在键空间中，随机移除某个key。")]),v._v(" "),_("p",[_("strong",[v._v("2）设置过期时间的键空间选择性移除")])]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("volatile-lru")]),v._v("：在设置了过期时间的键空间中，移除最近最少使用的key。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("volatile-random")]),v._v("：在设置了过期时间的键空间中，随机移除某个key。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("volatile-ttl")]),v._v("：在设置了过期时间的键空间中，有更早过期时间的key优先移除。")]),v._v(" "),_("p",[_("strong",[v._v("总结")])]),v._v(" "),_("p",[v._v("​\t\tRedis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。")]),v._v(" "),_("p",[_("strong",[v._v("7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？")])]),v._v(" "),_("p",[v._v("持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失")]),v._v(" "),_("p",[v._v("Redis 提供两种持久化机制 "),_("strong",[v._v("RDB（默认）")]),v._v(" 和 "),_("strong",[v._v("AOF 机制")])]),v._v(" "),_("p",[v._v("**RDB：**是Redis DataBase缩写快照")]),v._v(" "),_("p",[v._v("​\t\tRDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("优点：")])]),v._v(" "),_("p",[v._v("​\t1）只有一个文件 dump.rdb，方便持久化；")]),v._v(" "),_("p",[v._v("​\t2）容灾性好，一个文件可以保存到安全的磁盘。")]),v._v(" "),_("p",[v._v("​\t3）性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。")]),v._v(" "),_("p",[v._v("​\t4）相对于数据集大时，比 AOF 的启动效率更高。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("缺点：")])]),v._v(" "),_("p",[v._v("​\t1）数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候")]),v._v(" "),_("p",[_("strong",[v._v("AOF：持久化")])]),v._v(" "),_("p",[v._v("​\t\tAOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("优点：")])]),v._v(" "),_("p",[v._v("​\t1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。")]),v._v(" "),_("p",[v._v("​\t2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。")]),v._v(" "),_("p",[_("strong",[v._v("缺点：")])]),v._v(" "),_("p",[v._v("​\t1）AOF 文件比 RDB 文件大，且恢复速度慢。")]),v._v(" "),_("p",[v._v("​\t2）数据集大的时候，比 rdb 启动效率低。")]),v._v(" "),_("p",[_("strong",[v._v("8、redis事务")])]),v._v(" "),_("p",[v._v("​\t\t事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。")]),v._v(" "),_("p",[_("strong",[v._v("Redis事务的概念")])]),v._v(" "),_("p",[v._v("​\t\tRedis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。")]),v._v(" "),_("p",[v._v("Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的")]),v._v(" "),_("p",[v._v("Redis会将一个事务中的所有命令序列化，然后按顺序执行。")]),v._v(" "),_("p",[v._v("Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。")]),v._v(" "),_("p",[_("strong",[v._v("事务命令：")])]),v._v(" "),_("p",[v._v("**MULTI：**用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。")]),v._v(" "),_("p",[v._v("**EXEC：**执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。")]),v._v(" "),_("p",[v._v("**WATCH ：**是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。")]),v._v(" "),_("p",[v._v("**DISCARD：**调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。")]),v._v(" "),_("p",[_("strong",[v._v("UNWATCH")]),v._v("：命令可以取消watch对所有key的监控。")]),v._v(" "),_("p",[_("strong",[v._v("9、缓存雪崩和缓存穿透，以及解决方法")])]),v._v(" "),_("p",[_("strong",[v._v("【1】缓存雪崩：")])]),v._v(" "),_("p",[v._v("​\t\t指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("解决方案：")])]),v._v(" "),_("p",[v._v("​\t1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。")]),v._v(" "),_("p",[v._v("​\t2）一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。")]),v._v(" "),_("p",[v._v("​\t3）给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。")]),v._v(" "),_("p",[_("strong",[v._v("【2】缓存穿透：")])]),v._v(" "),_("p",[v._v("​\t\t缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("解决方案：")])]),v._v(" "),_("p",[v._v("​\t1）接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；")]),v._v(" "),_("p",[v._v("​\t2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；")]),v._v(" "),_("p",[v._v("​\t3）采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。")]),v._v(" "),_("p",[_("strong",[v._v("【3】缓存击穿：")])]),v._v(" "),_("p",[v._v("​\t\t这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库")]),v._v(" "),_("p",[v._v("​\t"),_("strong",[v._v("解决方案：")])]),v._v(" "),_("p",[v._v("​\t1）设置热点数据永远不过期")]),v._v(" "),_("p",[v._v("​\t2）加互斥锁，互斥锁")]),v._v(" "),_("p",[_("strong",[v._v("10、如何保证缓存和数据库的数据一致性？")])]),v._v(" "),_("p",[_("strong",[v._v("方式一：")])]),v._v(" "),_("p",[v._v("​\t\t读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。")]),v._v(" "),_("p",[_("strong",[v._v("方式二：")])]),v._v(" "),_("p",[v._v("​\t\t先更新数据库，假如读缓存失败，先读数据库，再回写缓存的方式实现")]),v._v(" "),_("p",[_("strong",[v._v("11、redis是单线程还是多线程？为什么那么快？")])]),v._v(" "),_("p",[v._v("redis是单线程，快的原因：")]),v._v(" "),_("p",[v._v("​\t\t1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；")]),v._v(" "),_("p",[v._v("​\t\t2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；")]),v._v(" "),_("p",[v._v("​\t\t3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；")]),v._v(" "),_("p",[v._v("​\t\t4）使用多路 I/O 复用模型，非阻塞 IO；")]),v._v(" "),_("p",[v._v("​\t\t5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")]),v._v(" "),_("p",[_("strong",[v._v("12、五种IO模型的区别")])]),v._v(" "),_("p",[_("strong",[v._v("阻塞I/O：")])]),v._v(" "),_("p",[v._v("​\t\t当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。")]),v._v(" "),_("p",[_("strong",[v._v("非阻塞I/O：")])]),v._v(" "),_("p",[v._v("​\t\t在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。")]),v._v(" "),_("p",[_("strong",[v._v("多路复用I/O（select和poll）：")])]),v._v(" "),_("p",[v._v("​\t\tIO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。其中，select只负责等，recvfrom只负责拷贝。 IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。")]),v._v(" "),_("p",[_("strong",[v._v("信号驱动I/O（SIGIO）：")])]),v._v(" "),_("p",[v._v("​\t\t信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。")]),v._v(" "),_("p",[_("strong",[v._v("异步I/O（Posix.1的aio_系列函数）：")])]),v._v(" "),_("p",[v._v("​\t\t当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。")]),v._v(" "),_("p",[_("strong",[v._v("可以看出，阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("13、select、poll、epoll的区别？")])]),v._v(" "),_("p",[v._v("参考：https://www.jianshu.com/p/dfd940e7fca2")]),v._v(" "),_("p",[_("strong",[v._v("select")]),v._v(" 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。")]),v._v(" "),_("p",[v._v("**poll **本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。")]),v._v(" "),_("p",[v._v("**epoll **支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。")]),v._v(" "),_("p",[_("strong",[v._v("14、redis热key问题？如何发现以及如何解决？")])]),v._v(" "),_("p",[v._v("​\t\t缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。")]),v._v(" "),_("p",[_("strong",[v._v("解决方案：")])]),v._v(" "),_("p",[v._v("​\t\t对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询")]),v._v(" "),_("p",[_("strong",[v._v("15、redis数据分布方式？有什么优点？一致性hash呢？")])]),v._v(" "),_("p",[_("strong",[v._v("Hash：")])]),v._v(" "),_("p",[v._v("​\t\t客户端分片：哈希+取余")]),v._v(" "),_("p",[v._v("​\t\t节点伸缩：数据节点关系变化，导致数据迁移")]),v._v(" "),_("p",[v._v("​\t\t迁移数量和添加节点数量有关：建议翻倍扩容")]),v._v(" "),_("p",[v._v("​\t\t一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。")]),v._v(" "),_("p",[_("strong",[v._v("一致性Hash：")])]),v._v(" "),_("p",[v._v("​\t\t客户端分片：哈希+顺时针（优化取余）")]),v._v(" "),_("p",[v._v("​\t\t节点伸缩：只影响邻近节点，但是还是有数据迁移")]),v._v(" "),_("p",[v._v("​\t\t翻倍伸缩：保证最小迁移数据和负载均衡")]),v._v(" "),_("p",[v._v("​\t\t一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这有带来均匀性的问题，即使可以将存储节点等距排列，也会在"),_("strong",[v._v("存储节点个数变化时带来数据的不均匀")]),v._v("。而这种可能成倍数的不均匀在实际工程中是不可接受的。")]),v._v(" "),_("p",[_("strong",[v._v("16、redis主从复制")])]),v._v(" "),_("p",[_("strong",[v._v("主从复制原理：")])]),v._v(" "),_("p",[v._v("当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。")]),v._v(" "),_("p",[v._v("如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，")]),v._v(" "),_("p",[v._v("同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，")]),v._v(" "),_("p",[v._v("接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。")]),v._v(" "),_("p",[v._v("slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。")]),v._v(" "),_("p",[_("strong",[v._v("过程原理")])]),v._v(" "),_("p",[v._v("​\t1、当从库和主库建立MS关系后，会向主数据库发送SYNC命令")]),v._v(" "),_("p",[v._v("​\t2、主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来")]),v._v(" "),_("p",[v._v("​\t3、当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis")]),v._v(" "),_("p",[v._v("​\t4、从Redis接收到后，会载入快照文件并且执行收到的缓存的命令")]),v._v(" "),_("p",[v._v("​\t5、之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致")]),v._v(" "),_("p",[_("strong",[v._v("缺点")])]),v._v(" "),_("p",[v._v("​\t所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决")])])}),[],!1,null,null,null);_.default=p.exports}}]);