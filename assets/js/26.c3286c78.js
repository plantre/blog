(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{443:function(a,t,s){"use strict";s.r(t);var e=s(2),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[a._v("#")]),a._v(" 集合")]),a._v(" "),t("h3",{attrs:{id:"collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[a._v("#")]),a._v(" Collection")]),a._v(" "),t("h4",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),t("h5",{attrs:{id:"arraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),t("p",[a._v("（数组）")]),a._v(" "),t("h5",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("（链表）")]),a._v(" "),t("h5",{attrs:{id:"vector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[a._v("#")]),a._v(" Vector")]),a._v(" "),t("p",[a._v("（数组实现、线程同步）")]),a._v(" "),t("h4",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),t("h5",{attrs:{id:"hashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" HashSet")]),a._v(" "),t("p",[a._v("（Hash 表）(底层由HashMap实现)")]),a._v(" "),t("h5",{attrs:{id:"treeset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[a._v("#")]),a._v(" TreeSet")]),a._v(" "),t("p",[a._v("（二叉树）")]),a._v(" "),t("p",[a._v("底层红黑树，支持自定义排序规则")]),a._v(" "),t("h5",{attrs:{id:"linkedhashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[a._v("#")]),a._v(" LinkedHashSet")]),a._v(" "),t("p",[a._v("（HashSet+LinkedHashMap）")]),a._v(" "),t("h4",{attrs:{id:"queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[a._v("#")]),a._v(" Queue")]),a._v(" "),t("p",[a._v("（单端队列，满足FIFO）")]),a._v(" "),t("h5",{attrs:{id:"deque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deque"}},[a._v("#")]),a._v(" Deque")]),a._v(" "),t("h6",{attrs:{id:"linkedlist-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist-2"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("(基于链表)")]),a._v(" "),t("p",[a._v("基于链表，支持存储Null，1.2存在，每次申请堆空间")]),a._v(" "),t("h6",{attrs:{id:"arraydeque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque"}},[a._v("#")]),a._v(" ArrayDeque")]),a._v(" "),t("p",[a._v("(基于数组)")]),a._v(" "),t("p",[a._v("基于可变长数组和双指针，不支持存储NULL，1.6引入，可能扩容，实现队列更好好")]),a._v(" "),t("h5",{attrs:{id:"priorityqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[a._v("#")]),a._v(" PriorityQueue")]),a._v(" "),t("p",[a._v("（基于堆）")]),a._v(" "),t("p",[a._v("优先级最高的元素先出队，利用了二叉堆，时间复杂度logn，不支持存储 NULL 和 non-comparable 的对象，默认是小顶堆，可接收 Comparator 定义元素优先级的先后")]),a._v(" "),t("h3",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),t("h5",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("p",[a._v("（数组+链表+红黑树)")]),a._v(" "),t("p",[a._v("（可以存储 null 的 k和 v，容量初始16，2n，指定大小将其扩充为 2 的幂次方大小）使用 Collections.synchronizedMap() 方法来包装我们的 HashMap，底层数据结构是数组+链表/红黑树，负载因子0.75，超过size*0.75就扩容，只有大小为2次幂时，才能合理用位运算替代取模（高效），数组>64&&链表>8,链表变红黑树，红黑树<6，红黑树变链表，取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，")]),a._v(" "),t("h5",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("p",[a._v("（可排序）")]),a._v(" "),t("p",[a._v("红黑树，可排序，通过Comparator排序，对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力")]),a._v(" "),t("h5",{attrs:{id:"linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),t("p",[a._v("（记录插入顺序）")]),a._v(" "),t("p",[a._v("底层数据结构是数组+链表/红黑树+双向链表，插入有序")]),a._v(" "),t("h5",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" HashTable")]),a._v(" "),t("p",[a._v("（安全）")]),a._v(" "),t("p",[a._v("方法基本都经过synchronized 修饰，被淘汰，不允许有 null 键和 null 值，容量初始11，2n+1，使用 synchronized 来保证线程安全，效率非常低下")]),a._v(" "),t("h3",{attrs:{id:"collections"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collections"}},[a._v("#")]),a._v(" Collections")]),a._v(" "),t("h4",{attrs:{id:"排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[a._v("#")]),a._v(" 排序")]),a._v(" "),t("p",[a._v("reverse(List list)//反转")]),a._v(" "),t("p",[a._v("sort(List list)//按自然排序的升序排序")]),a._v(" "),t("p",[a._v("sort(List list, Comparator c)//定制排序")]),a._v(" "),t("h4",{attrs:{id:"查找替换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找替换"}},[a._v("#")]),a._v(" 查找替换")]),a._v(" "),t("p",[a._v("fill(List list, Object obj)//用指定的元素代替指定list中的所有元素")]),a._v(" "),t("p",[a._v("replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素")]),a._v(" "),t("h4",{attrs:{id:"同步控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步控制"}},[a._v("#")]),a._v(" 同步控制")]),a._v(" "),t("p",[a._v("synchronizedXxx()")])])}),[],!1,null,null,null);t.default=r.exports}}]);