(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{466:function(t,n,v){"use strict";v.r(n);var _=v(2),s=Object(_.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[n("strong",[t._v("1、Spring IOC")])]),t._v(" "),n("p",[t._v("​\t\tIoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制\n权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。")]),t._v(" "),n("p",[t._v("​\t\tIoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。")]),t._v(" "),n("p",[n("strong",[t._v("2、Spring AOP，动态代理")])]),t._v(" "),n("p",[t._v("​\t\tAOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤\n的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模\n块间的耦合度，并有利于未来的可拓展性和可维护性。")]),t._v(" "),n("p",[t._v("​\t\tSpring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK\nProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候\nSpring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，")]),t._v(" "),n("p",[n("strong",[t._v("3、Bean生命周期")])]),t._v(" "),n("p",[n("strong",[t._v("单例对象：")]),t._v(" singleton")]),t._v(" "),n("p",[t._v("出生：当容器创建时对象出生")]),t._v(" "),n("p",[t._v("活着：只要容器还在，对象一直活着")]),t._v(" "),n("p",[t._v("死亡：容器销毁，对象消亡")]),t._v(" "),n("p",[t._v("总结：单例对象的生命周期和容器相同")]),t._v(" "),n("p",[n("strong",[t._v("多例对象：")]),t._v(" prototype")]),t._v(" "),n("p",[t._v("出生: 使用对象时spring框架为我们创建")]),t._v(" "),n("p",[t._v("活着：对象只要是在使用过程中就一直活着")]),t._v(" "),n("p",[t._v("死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收")]),t._v(" "),n("p",[n("strong",[t._v("4、Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?")])]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("名称")]),t._v(" "),n("th")])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("singleton")]),t._v(" "),n("td",[t._v("单例对象，默认值的作用域")])]),t._v(" "),n("tr",[n("td",[t._v("prototype")]),t._v(" "),n("td",[t._v("每次获取都会创建⼀个新的 bean 实例")])]),t._v(" "),n("tr",[n("td",[t._v("request")]),t._v(" "),n("td",[t._v("每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。")])]),t._v(" "),n("tr",[n("td",[t._v("session")]),t._v(" "),n("td",[t._v("在一次 HTTP session 中，容器将返回同一个实例")])]),t._v(" "),n("tr",[n("td",[t._v("global-session")]),t._v(" "),n("td",[t._v("将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session")])])])]),t._v(" "),n("p",[t._v("默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题")]),t._v(" "),n("p",[n("strong",[t._v("保障线程安全方法：")])]),t._v(" "),n("ol",[n("li",[n("p",[t._v("在Bean对象中尽量避免定义可变的成员变量（不太现实）。")])]),t._v(" "),n("li",[n("p",[t._v("在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中")])])]),t._v(" "),n("p",[n("strong",[t._v("ThreadLocal")]),t._v("：")]),t._v(" "),n("p",[t._v("​\t\t每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。")]),t._v(" "),n("p",[t._v("​\t\t将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后"),n("strong",[t._v("在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象")]),t._v("，避免了将这个对象作为参数传递的麻烦。")]),t._v(" "),n("p",[n("strong",[t._v("5、Spring事务隔离级别和事务传播属性")])]),t._v(" "),n("p",[n("strong",[t._v("隔离级别：")])]),t._v(" "),n("p",[n("strong",[t._v("1) DEFAULT （默认）")]),t._v("\n这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。")]),t._v(" "),n("p",[n("strong",[t._v("2) READ_UNCOMMITTED （读未提交）")]),t._v("\n这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。")]),t._v(" "),n("p",[n("strong",[t._v("3) READ_COMMITTED （读已提交）")]),t._v("\n保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。")]),t._v(" "),n("p",[n("strong",[t._v("4) REPEATABLE_READ （可重复读）")]),t._v("\n这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。")]),t._v(" "),n("p",[n("strong",[t._v("5) SERIALIZABLE（串行化）")]),t._v("\n这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。")]),t._v(" "),n("p",[n("strong",[t._v("Spring事务传播属性（Propagation）：")])]),t._v(" "),n("p",[n("strong",[t._v("1) REQUIRED（默认属性）")]),t._v("\n如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。")]),t._v(" "),n("p",[n("strong",[t._v("2) MANDATORY")]),t._v("\n支持当前事务，如果当前没有事务，就抛出异常。")]),t._v(" "),n("p",[n("strong",[t._v("3) NEVER")]),t._v("\n以非事务方式执行，如果当前存在事务，则抛出异常。")]),t._v(" "),n("p",[n("strong",[t._v("4) NOT_SUPPORTED")]),t._v("\n以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。")]),t._v(" "),n("p",[n("strong",[t._v("5) REQUIRES_NEW")]),t._v("\n新建事务，如果当前存在事务，把当前事务挂起。")]),t._v(" "),n("p",[n("strong",[t._v("6) SUPPORTS")]),t._v("\n支持当前事务，如果当前没有事务，就以非事务方式执行。")]),t._v(" "),n("p",[n("strong",[t._v("7) NESTED")]),t._v("\n支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。")]),t._v(" "),n("p",[n("strong",[t._v("6、Spring以及Spring MVC常见注解")])]),t._v(" "),n("p",[n("em",[n("strong",[t._v("Spring部分：")])])]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("声明bean的注解")])]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Component")]),t._v(" 通⽤的注解，可标注任意类为  Spring 组件")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Service")]),t._v(" 在业务逻辑层使用（service层）")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Repository")]),t._v(" 在数据访问层使用（dao层）")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Controller")]),t._v(" 在展现层使用，控制器的声明（controller层）")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("注入bean的注解")])]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Autowired")]),t._v("：可以对类成员变量、方法、构造方法进行标注")]),t._v(" "),n("p",[t._v("​\t\t\t默认按照类型注入，若要按照名称注入，需要搭配**@Qualifier**注解一起使用")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Resource")]),t._v("：默认按照名称来装配注入")]),t._v(" "),n("p",[n("strong",[t._v("Spring MVC部分：")])]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@Controller")]),t._v(" 声明该类为SpringMVC中的Controller")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@RequestMapping")]),t._v(" 用于映射Web请求")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@ResponseBody")]),t._v(" 支持将返回值放在response内，而不是一个页面，通常用户返回json数据")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@RequestBody")]),t._v(" 允许request的参数在request体中，而不是在直接连接在地址后面。")]),t._v(" "),n("p",[t._v("​\t"),n("strong",[t._v("@PathVariable")]),t._v(' 用于接收路径参数，比如@RequestMapping("/hello/{name}")申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。')]),t._v(" "),n("p",[n("strong",[t._v("7、@autowired和@resource的区别？")])]),t._v(" "),n("p",[n("strong",[t._v("@Autowired")]),t._v("：可以对类成员变量、方法、构造方法进行标注")]),t._v(" "),n("p",[t._v("​\t\t\t默认按照类型注入，若要按照名称注入，需要搭配**@Qualifier**注解一起使用")]),t._v(" "),n("p",[n("strong",[t._v("@Resource")]),t._v("：默认按照名称来装配注入")]),t._v(" "),n("p",[n("strong",[t._v("8、mybatis如何防止sql注入？$和#的区别是什么？传入表名用哪个？")])]),t._v(" "),n("p",[n("strong",[t._v("防止sql注入：")])]),t._v(" "),n("p",[t._v("​\t在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式")]),t._v(" "),n("p",[n("strong",[t._v("#和$区别：")])]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("#")]),t._v(" "),n("th",[t._v("$")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("相当于对数据加上双引号")]),t._v(" "),n("td",[t._v("相当于直接显示数据")])]),t._v(" "),n("tr",[n("td",[t._v("很大程度上防止SQL注入")]),t._v(" "),n("td",[t._v("无法防止SQL注入")])]),t._v(" "),n("tr",[n("td",[t._v("#{xxx},使用的是PreparedStatement,会有类型转换，比较安全")]),t._v(" "),n("td",[t._v("${xxx}，使用字符串拼接，容易SQL注入")])])])]),t._v(" "),n("p",[t._v("​\t\t简单的说就是#{}是经过预编译的，是安全的，"),n("strong",[t._v("$")]),t._v("{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。")]),t._v(" "),n("p",[t._v("要实现动态传入表名、列名，需要做如下修改：")]),t._v(" "),n("p",[n("strong",[t._v('添加属性statementType="STATEMENT"')]),t._v("，"),n("strong",[t._v("同时sql里的属有变量取值都改成${xxxx}")])]),t._v(" "),n("p",[n("strong",[t._v("9、Spring MVC工作原理")])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20181022224058617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F3YWtlX2xxaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:""}})]),t._v(" "),n("ol",[n("li",[t._v("客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。")]),t._v(" "),n("li",[t._v("DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。")]),t._v(" "),n("li",[t._v("解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。")]),t._v(" "),n("li",[t._v("HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。")]),t._v(" "),n("li",[t._v("处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象")]),t._v(" "),n("li",[t._v("ViewResolver 会根据逻辑  View 查找实际的  View 。")]),t._v(" "),n("li",[t._v("DispaterServlet 把返回的  Model 传给  View （视图渲染）。")]),t._v(" "),n("li",[t._v("把  View 返回给请求者（浏览器）")])]),t._v(" "),n("p",[n("strong",[t._v("10、SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.")])]),t._v(" "),n("p",[t._v("启动类：")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@SpringBootApplication")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("JpaApplication")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SpringApplication")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("JpaApplication")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br")])]),n("p",[t._v("它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。")]),t._v(" "),n("p",[n("strong",[t._v("@EnableAutoConfiguration作用：")])]),t._v(" "),n("p",[t._v("它主要利用了一个")]),t._v(" "),n("p",[t._v("EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Import")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnableAutoConfigurationImportSelector")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@interface")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnableAutoConfiguration")]),t._v(" \n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br")])]),n("p",[n("strong",[t._v("@SpringBootApplication")]),t._v("注解等同于下面三个注解：")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("@SpringBootConfiguration：")]),t._v(" 底层是"),n("strong",[t._v("Configuration")]),t._v("注解，说白了就是支持"),n("strong",[t._v("JavaConfig")]),t._v("的方式来进行配置")]),t._v(" "),n("li",[n("strong",[t._v("@EnableAutoConfiguration："),n("strong",[t._v("开启")]),t._v("自动配置")]),t._v("功能")]),t._v(" "),n("li",[n("strong",[t._v("@ComponentScan："),n("strong",[t._v("就是")]),t._v("扫描")]),t._v("注解，默认是扫描"),n("strong",[t._v("当前类下")]),t._v("的package")])]),t._v(" "),n("p",[t._v("其中"),n("code",[t._v("@EnableAutoConfiguration")]),t._v("是关键(启用自动配置)，内部实际上就去加载"),n("code",[t._v("META-INF/spring.factories")]),t._v("文件的信息，然后筛选出以"),n("code",[t._v("EnableAutoConfiguration")]),t._v("为key的数据，加载到IOC容器中，实现自动配置功能！")]),t._v(" "),n("p",[n("strong",[t._v("11、Mybatis和Hibernate的区别")])]),t._v(" "),n("p",[n("strong",[t._v("Hibernate 框架：")])]),t._v(" "),n("p",[t._v("​    "),n("strong",[t._v("Hibernate")]),t._v("是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。")]),t._v(" "),n("p",[n("strong",[t._v("Mybatis框架：")])]),t._v(" "),n("p",[t._v("​    "),n("strong",[t._v("Mybatis")]),t._v("是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。")]),t._v(" "),n("p",[n("strong",[t._v("区别：")])]),t._v(" "),n("p",[n("strong",[t._v("开发方面")])]),t._v(" "),n("p",[t._v("​    在项目开发过程当中，就速度而言：")]),t._v(" "),n("p",[t._v("​      hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；")]),t._v(" "),n("p",[t._v("​      Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；")]),t._v(" "),n("p",[t._v("​    但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。")]),t._v(" "),n("p",[n("strong",[t._v("sql优化方面")])]),t._v(" "),n("p",[t._v("​    Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；")]),t._v(" "),n("p",[t._v("​    Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；")]),t._v(" "),n("p",[n("strong",[t._v("对象管理比对")])]),t._v(" "),n("p",[t._v("​    Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；")]),t._v(" "),n("p",[t._v("​    Mybatis 需要自行管理 映射关系；")]),t._v(" "),n("p",[n("strong",[t._v("12、spring中的@Autowired注解原理？")])]),t._v(" "),n("p",[t._v("​\t\t @Autowired的使用简化了我们的开发，其原理是使用 AutowiredAnnotationBeanPostProcessor 类来实现，该类实现了 Spring 框架的一些扩展接口，通过实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）；通过实现 MergedBeanDefinitionPostProcessor 扩展接口，在 BeanFactory 里面的每个 Bean 实例化前获取到每个 Bean 里面的 @Autowired 信息并缓存下来；通过实现 Spring 框架的 postProcessPropertyValues 扩展接口在 BeanFactory 里面的每个 Bean 实例后从缓存取出对应的注解信息，获取依赖对象，并通过反射设置到 Bean 属性里面。")]),t._v(" "),n("p",[n("strong",[t._v("13、Spring中用到了哪些设计模式？单例、工厂、代理、适配、观察者之类的说一说就行")])]),t._v(" "),n("p",[t._v("参考："),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd",target:"_blank",rel:"noopener noreferrer"}},[t._v("spring中的设计模式"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("strong",[t._v("单例设计模式 :")]),t._v(" Spring 中的 Bean 默认都是单例的。")]),t._v(" "),n("p",[n("strong",[t._v("⼯⼚设计模式 :")]),t._v(" Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建bean 对象。")]),t._v(" "),n("p",[n("strong",[t._v("代理设计模式 :")]),t._v(" Spring AOP 功能的实现。")]),t._v(" "),n("p",[n("strong",[t._v("观察者模式：")]),t._v(" Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。")]),t._v(" "),n("p",[t._v("**适配器模式：**Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。")])])}),[],!1,null,null,null);n.default=s.exports}}]);