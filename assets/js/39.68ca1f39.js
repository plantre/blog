(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{455:function(e,v,_){"use strict";_.r(v);var o=_(2),t=Object(o.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"sql优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql优化"}},[e._v("#")]),e._v(" SQL优化")]),e._v(" "),v("p",[v("strong",[e._v("1. 在读表的时候，尽可能的避免全表扫描，合理的根据业务需求，在"),v("code",[e._v("where")]),e._v("及"),v("code",[e._v("order by")]),e._v("涉及的列上建立索引。")])]),e._v(" "),v("p",[v("strong",[e._v("2. 应尽量避免在"),v("code",[e._v("where")]),e._v("字句中使用"),v("code",[e._v("!=")]),e._v("或 "),v("code",[e._v("<>")]),e._v(" 操作符，否则将引擎会放弃索引而走全表扫描。")])]),e._v(" "),v("p",[v("strong",[e._v("3. 尽量避免"),v("code",[e._v("where")]),e._v("字句中对字段进行"),v("code",[e._v("null")]),e._v("值判断，否则也会导致引擎放弃索引而走全表扫描。可以用0代替判断，前提是保证字段不能为null。")])]),e._v(" "),v("p",[v("strong",[e._v("4. 尽量避免在"),v("code",[e._v("where")]),e._v("字句中用"),v("code",[e._v("or")]),e._v("拼接，否则也会走全表扫描。可以通过"),v("code",[e._v("union all")]),e._v(" 拼接代替。")])]),e._v(" "),v("p",[v("strong",[e._v("5. 尽量不适用"),v("code",[e._v("Like")]),e._v("做搜索查询，诺要提高效率，可以采用全文检索。")])]),e._v(" "),v("p",[v("strong",[e._v("6. 尽量不适用"),v("code",[e._v("In")]),e._v("或 "),v("code",[e._v("Not in")]),e._v("查询，否则会导致全表扫描。对于连续的数字，可以用"),v("code",[e._v("between")]),e._v("代替 "),v("code",[e._v("in")]),e._v("。比如："),v("code",[e._v("select id from t where num between 1 and 3")])])]),e._v(" "),v("p",[v("strong",[e._v("7. 如果在"),v("code",[e._v("where")]),e._v("字句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。比如："),v("code",[e._v("select id from t where num=@num")])]),e._v("\n** 可以改为强制查询使用索引："),v("code",[e._v("select id from t with(index(索引名)) where num=@num")]),e._v("**")]),e._v(" "),v("p",[v("strong",[e._v("8. 尽量避免在 "),v("code",[e._v("where")]),e._v("子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。比如："),v("code",[e._v("select id from t where num/2=100")])])]),e._v(" "),v("p",[v("strong",[e._v("9. 应尽量避免在where子句中对字段进行函数操作。")])]),e._v(" "),v("p",[v("strong",[e._v("10. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。")])]),e._v(" "),v("p",[v("strong",[e._v("11. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 "),v("code",[e._v("sex，male、female")]),e._v("几乎各一半，那么即使在"),v("code",[e._v("sex")]),e._v("上建了索引也对查询效率起不了作用。")])]),e._v(" "),v("p",[v("strong",[e._v("12. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。")])]),e._v(" "),v("p",[v("strong",[e._v("13. 应尽可能的避免更新 "),v("code",[e._v("clustered")]),e._v("（聚集）索引数据列，因为 "),v("code",[e._v("clustered")]),e._v("索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 "),v("code",[e._v("clustered")]),e._v("索引数据列，那么需要考虑是否应将该索引建为 "),v("code",[e._v("clustered")]),e._v("索引。一个表只能有一个聚集索引，比如表中的时间列。")])]),e._v(" "),v("p",[v("strong",[e._v("14. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。")])]),e._v(" "),v("p",[v("strong",[e._v("15. 尽可能的使用 "),v("code",[e._v("varchar/nvarchar")]),e._v(" 代替 "),v("code",[e._v("char/nchar")]),e._v(" ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。")])]),e._v(" "),v("p",[v("strong",[e._v("16. 尽量不要"),v("code",[e._v("select")]),e._v("查询"),v("code",[e._v("\\*")]),e._v("全部信息，只读取所需要的字段。")])]),e._v(" "),v("p",[v("strong",[e._v("17. 避免频繁创建和删除临时表，以减少系统表资源的消耗。")])]),e._v(" "),v("p",[v("strong",[e._v("18. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 "),v("code",[e._v("select into")]),e._v(" 代替 "),v("code",[e._v("create table")]),e._v("，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先"),v("code",[e._v("create table")]),e._v("，然后"),v("code",[e._v("insert")]),e._v("。")])]),e._v(" "),v("p",[v("strong",[e._v("19. 尽量避免大事务操作，提高系统并发能力。")])]),e._v(" "),v("p",[v("strong",[e._v("20. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。")])]),e._v(" "),v("p",[v("strong",[e._v("21. 升级服务器")])])])}),[],!1,null,null,null);v.default=t.exports}}]);