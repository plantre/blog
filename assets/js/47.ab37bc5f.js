(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{464:function(a,t,s){"use strict";s.r(t);var _=s(2),v=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"为什么那么快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么那么快"}},[a._v("#")]),a._v(" 为什么那么快")]),a._v(" "),t("h3",{attrs:{id:"基于内存实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于内存实现"}},[a._v("#")]),a._v(" 基于内存实现")]),a._v(" "),t("h3",{attrs:{id:"高效的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高效的数据结构"}},[a._v("#")]),a._v(" 高效的数据结构")]),a._v(" "),t("h3",{attrs:{id:"丰富而合理的编码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#丰富而合理的编码"}},[a._v("#")]),a._v(" 丰富而合理的编码")]),a._v(" "),t("h3",{attrs:{id:"写时拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写时拷贝"}},[a._v("#")]),a._v(" 写时拷贝")]),a._v(" "),t("p",[a._v("（CopyOnWrite）")]),a._v(" "),t("p",[a._v("内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟空间结构，但是不为这些段分配物理内存")]),a._v(" "),t("h3",{attrs:{id:"零拷贝技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝技术"}},[a._v("#")]),a._v(" 零拷贝技术")]),a._v(" "),t("p",[a._v("直接从 PageCache 中把数据复制到 Socket 缓冲区中，不用把数据复制到用户内存空间，DMA 控制器可以直接完成数据复制，不需要 CPU 参与，速度更快")]),a._v(" "),t("h3",{attrs:{id:"客户端管道批量命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端管道批量命令"}},[a._v("#")]),a._v(" 客户端管道批量命令")]),a._v(" "),t("h3",{attrs:{id:"单线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[a._v("#")]),a._v(" 单线程")]),a._v(" "),t("h3",{attrs:{id:"合适的线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合适的线程模型"}},[a._v("#")]),a._v(" 合适的线程模型")]),a._v(" "),t("p",[a._v("I/O 多路复用")]),a._v(" "),t("h3",{attrs:{id:"redis6-0后引入多线程提速"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis6-0后引入多线程提速"}},[a._v("#")]),a._v(" Redis6.0后引入多线程提速")]),a._v(" "),t("h2",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),t("h3",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[a._v("#")]),a._v(" string")]),a._v(" "),t("p",[a._v("适用于简单key-value存储、setnx key value实现分布式锁、计数器(原子性)、分布式全局唯一ID")]),a._v(" "),t("p",[a._v("底层：用char[]数组表示，源码中用SDS(simple dynamic string)封装char[]，这是是Redis存储的最小单元，一个SDS最大可以存储512M信息，")]),a._v(" "),t("p",[a._v("Redis对SDS再次封装生成了RedisObject，type = REDIS_STRING,Redis会创建键的RedisObject 和 值的RedisOjbect")]),a._v(" "),t("p",[a._v("自动存储int类型，非int类型用raw编码")]),a._v(" "),t("p",[t("strong",[a._v("OBJ_ENCODING_EMBSTR")])]),a._v(" "),t("p",[a._v("Redis针对短字符串的优化")]),a._v(" "),t("p",[a._v("内存申请和释放都只需要调用一次内存操作函数")]),a._v(" "),t("p",[a._v("redisObject、sdshdr结构保存在一块连续的内存中，减少了内存碎片")]),a._v(" "),t("p",[t("strong",[a._v("OBJ_ENCODING_RAW")])]),a._v(" "),t("p",[a._v("长度大于OBJ_ENCODING_EMBSTR_SIZE_LIMIT的字符串，在该编码中，redisObject、sds结构存放在两个不连续的内存块中")]),a._v(" "),t("p",[t("strong",[a._v("OBJ_ENCODING_INT")])]),a._v(" "),t("p",[a._v("将数值型字符串转换为整型，可以大幅降低数据占用的内存空间")]),a._v(" "),t("h4",{attrs:{id:"sds"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sds"}},[a._v("#")]),a._v(" sds")]),a._v(" "),t("p",[a._v("获取字符串长度复杂度为O(1),因为前期已经将字符串的长度写在len这个变量里面了")]),a._v(" "),t("p",[a._v("SDS在修改的时候，Redis的API会主动将SDS的大小扩展到执行修改所需要的大小，然后才执行实际的修改操作")]),a._v(" "),t("p",[a._v("C 字符串 只能保存文本数据,比如“\\0”")]),a._v(" "),t("p",[a._v("通过空间预分配和惰性空间释放两种方法，搭配len和free两个变量，来实现对内存分配策略的优化,减少修改字符串时带来的内存重分配次数")]),a._v(" "),t("p",[a._v("1.C字符串中，更改字符串长度，内存就会重新分配，而SDS不需要每次都进行重新分配")]),a._v(" "),t("p",[a._v("2.空间预分配,当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间")]),a._v(" "),t("p",[a._v("小于1MB，*2")]),a._v(" "),t("p",[a._v("于等于1MB,=1m")]),a._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" list")]),a._v(" "),t("p",[a._v("lpush + lpop = stack 先进后出的栈")]),a._v(" "),t("p",[a._v("lpush + rpop = queue 先进先出的队列")]),a._v(" "),t("p",[a._v("lpush + ltrim = capped collection 有限集合")]),a._v(" "),t("p",[a._v("lpush + brpop = message queue 消息队列")]),a._v(" "),t("p",[a._v("字符串长度且元素个数小于一定范围使用 ziplist 编码，否则转化为 linkedlist 编码")]),a._v(" "),t("h3",{attrs:{id:"hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[a._v("#")]),a._v(" hash")]),a._v(" "),t("h4",{attrs:{id:"渐进式rehash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渐进式rehash"}},[a._v("#")]),a._v(" 渐进式rehash")]),a._v(" "),t("p",[a._v("rehashidx != -1则表示扩容到数组中的第几个了")]),a._v(" "),t("p",[t("strong",[a._v("load_factor = ht[0].used / ht[0].size")])]),a._v(" "),t("h6",{attrs:{id:"_0-1收缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-1收缩"}},[a._v("#")]),a._v(" <0.1收缩")]),a._v(" "),t("h6",{attrs:{id:"_1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[a._v("#")]),a._v(" >=1")]),a._v(" "),t("h6",{attrs:{id:"_5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5"}},[a._v("#")]),a._v(" >=5")]),a._v(" "),t("p",[a._v("服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令")]),a._v(" "),t("p",[a._v("K是字符串，V是多种")]),a._v(" "),t("h3",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" set")]),a._v(" "),t("p",[a._v("保存元素为整数及元素个数小于一定范围使用 intset 编码，任意条件不满足，则使用 hashtable 编码")]),a._v(" "),t("h3",{attrs:{id:"zset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zset"}},[a._v("#")]),a._v(" zset")]),a._v(" "),t("p",[a._v("底层：跳表，查找数据时，是从上往下，从左往右进行查找。")]),a._v(" "),t("p",[a._v("保存的元素个数小于定值且成员长度小于定值使用 ziplist 编码，任意条件不满足，则使用 skiplist 编码")]),a._v(" "),t("h6",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),t("p",[a._v("积分排行榜")]),a._v(" "),t("p",[a._v("时间排序新闻")]),a._v(" "),t("p",[a._v("延时队列")]),a._v(" "),t("h3",{attrs:{id:"redis-geo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-geo"}},[a._v("#")]),a._v(" Redis Geo")]),a._v(" "),t("p",[a._v("GEO利用 GeoHash 将二维的经纬度转换成字符串，来实现位置的划分跟指定距离的查询")]),a._v(" "),t("h3",{attrs:{id:"hyperloglog"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog"}},[a._v("#")]),a._v(" HyperLogLog")]),a._v(" "),t("h3",{attrs:{id:"bitmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[a._v("#")]),a._v(" bitmap")]),a._v(" "),t("h6",{attrs:{id:"应用-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用-2"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),t("p",[a._v("用户签到")]),a._v(" "),t("p",[a._v("统计活跃用户")]),a._v(" "),t("h3",{attrs:{id:"bloom-filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bloom-filter"}},[a._v("#")]),a._v(" Bloom Filter")]),a._v(" "),t("p",[a._v("不存在的一定不存在，存在的不一定存在")]),a._v(" "),t("h2",{attrs:{id:"持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[a._v("#")]),a._v(" 持久化")]),a._v(" "),t("h3",{attrs:{id:"快照-rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快照-rdb"}},[a._v("#")]),a._v(" 快照-RDB")]),a._v(" "),t("p",[a._v("（snapshotting）")]),a._v(" "),t("h3",{attrs:{id:"只追加文件-aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#只追加文件-aof"}},[a._v("#")]),a._v(" 只追加文件-AOF")]),a._v(" "),t("p",[a._v("（append-only file）")]),a._v(" "),t("h2",{attrs:{id:"高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高可用"}},[a._v("#")]),a._v(" 高可用")]),a._v(" "),t("h3",{attrs:{id:"单机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单机"}},[a._v("#")]),a._v(" 单机")]),a._v(" "),t("p",[a._v("架构简单，部署方便")]),a._v(" "),t("p",[a._v("机器故障、容量瓶颈、QPS瓶颈")]),a._v(" "),t("h3",{attrs:{id:"主从复制-6379"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制-6379"}},[a._v("#")]),a._v(" 主从复制（6379）")]),a._v(" "),t("p",[a._v("高可靠性，读写分离")]),a._v(" "),t("p",[a._v("故障恢复复杂，主库的写跟存受单机限制")]),a._v(" "),t("h4",{attrs:{id:"一主一从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一主一从"}},[a._v("#")]),a._v(" 一主一从")]),a._v(" "),t("p",[a._v("slaveof/slaveof no one")]),a._v(" "),t("p",[a._v("从节点只读\tslave-read-only = yes")]),a._v(" "),t("p",[a._v("网络延迟\trepl-disable-tcp-nodelay no\t当开启时，主节点会合并较小的 TCP 数据包从而节省带宽")]),a._v(" "),t("h4",{attrs:{id:"一主多从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一主多从"}},[a._v("#")]),a._v(" 一主多从")]),a._v(" "),t("p",[a._v("replicaof/info replication")]),a._v(" "),t("h4",{attrs:{id:"树状主从结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树状主从结构"}},[a._v("#")]),a._v(" 树状主从结构")]),a._v(" "),t("h3",{attrs:{id:"哨兵模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[a._v("#")]),a._v(" 哨兵模式")]),a._v(" "),t("p",[a._v("-Redis Sentinel （26379）")]),a._v(" "),t("p",[t("strong",[a._v("优点：")])]),a._v(" "),t("p",[a._v("集群部署简单，HA")]),a._v(" "),t("p",[t("strong",[a._v("缺点：")])]),a._v(" "),t("p",[a._v("原理繁琐，slave存在资源浪费，不能解决读写分离问题")]),a._v(" "),t("p",[a._v("当主节点出现故障时，Redis Sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用")]),a._v(" "),t("p",[a._v("redis-server sentinel.conf --sentinel")]),a._v(" "),t("p",[a._v("监控")]),a._v(" "),t("p",[a._v("通知")]),a._v(" "),t("p",[a._v("主节点故障转移")]),a._v(" "),t("p",[a._v("配置提供者")]),a._v(" "),t("h4",{attrs:{id:"脑裂问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#脑裂问题"}},[a._v("#")]),a._v(" 脑裂问题")]),a._v(" "),t("p",[a._v("因为网络原因，导致master节点、slave节点 和 sentinel集群处于不用的网络分区，因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点")]),a._v(" "),t("h2",{attrs:{id:"高并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发"}},[a._v("#")]),a._v(" 高并发")]),a._v(" "),t("h3",{attrs:{id:"集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[a._v("#")]),a._v(" 集群")]),a._v(" "),t("p",[a._v("数据动态存储solt，可扩展，高可用")]),a._v(" "),t("p",[a._v("客户端动态感知后端变更，批量操作支持查")]),a._v(" "),t("p",[t("code",[a._v("redis-cli --cluster create 192.168.153.128:6379 192.168.153.131:6379 192.168.153.132:6379")])]),a._v(" "),t("p",[t("code",[a._v("redis-cli --cluster add-node 192.168.153.129:6379 192.168.153.128:6379 --cluster-slave --cluster-master-id a7e948208badf171d19dbfe2d444ea7295bdbf60")])]),a._v(" "),t("p",[t("code",[a._v("redis-cli --cluster check 192.168.153.128:6379 --cluster-search-multiple-owners")])]),a._v(" "),t("p",[t("code",[a._v("redis-cli --cluster info 192.168.153.128:6379")])]),a._v(" "),t("p",[t("strong",[a._v("为什么RedisCluster设计成16384个槽")])]),a._v(" "),t("p",[a._v("如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。\n如上所述，在消息头中，最占空间的是myslots[CLUSTER_SLOTS/8]。\n当槽位为65536时，这块的大小是:\n65536÷8÷1024=8kb")]),a._v(" "),t("p",[a._v("redis的集群主节点数量基本不可能超过1000个")]),a._v(" "),t("p",[a._v("槽位越小，节点少的情况下，压缩率高")]),a._v(" "),t("h2",{attrs:{id:"常见问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[a._v("#")]),a._v(" 常见问题")]),a._v(" "),t("h3",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),t("p",[a._v("Redis中大批量key在同一时间同时失效导致所有请求都打到了MySQL")]),a._v(" "),t("h5",{attrs:{id:"解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[a._v("#")]),a._v(" 解决")]),a._v(" "),t("p",[a._v("缓存数据的过期时间加上个随机值")]),a._v(" "),t("p",[a._v("如果缓存数据库是分布式部署，将热点数据均匀分布在不同得缓存数据库中")]),a._v(" "),t("p",[a._v("设置热点数据永远不过期")]),a._v(" "),t("h3",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),t("p",[a._v("指缓存和数据库中都没有的数据")]),a._v(" "),t("h5",{attrs:{id:"解决-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决-2"}},[a._v("#")]),a._v(" 解决")]),a._v(" "),t("p",[a._v("后端接口层增加 用户鉴权校验，参数做校验等")]),a._v(" "),t("p",[a._v("单个IP每秒访问次数超过阈值直接拉黑IP")]),a._v(" "),t("p",[a._v("从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null 失效时间可以为15秒防止恶意攻击")]),a._v(" "),t("p",[a._v("用Redis提供的  Bloom Filter 特性也OK")]),a._v(" "),t("h3",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[a._v("#")]),a._v(" 缓存击穿")]),a._v(" "),t("p",[a._v("大并发集中对这一个热点key进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库")]),a._v(" "),t("h5",{attrs:{id:"解决-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决-3"}},[a._v("#")]),a._v(" 解决")]),a._v(" "),t("p",[a._v("设置热点数据永远不过期")]),a._v(" "),t("p",[a._v("加上互斥锁")]),a._v(" "),t("h3",{attrs:{id:"双写一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双写一致性"}},[a._v("#")]),a._v(" 双写一致性")]),a._v(" "),t("p",[a._v("先更新数据库，再更新缓存")]),a._v(" "),t("p",[a._v("先删缓存，再更新数据库")]),a._v(" "),t("h6",{attrs:{id:"cache-aside-pattern"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-aside-pattern"}},[a._v("#")]),a._v(" Cache Aside Pattern")]),a._v(" "),t("p",[a._v("更新 DB，然后直接删除 cache")]),a._v(" "),t("h3",{attrs:{id:"事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),t("h3",{attrs:{id:"过期策略和内存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过期策略和内存淘汰策略"}},[a._v("#")]),a._v(" 过期策略和内存淘汰策略")]),a._v(" "),t("h4",{attrs:{id:"过期策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[a._v("#")]),a._v(" 过期策略")]),a._v(" "),t("p",[a._v("定时过期")]),a._v(" "),t("p",[a._v("惰性过期")]),a._v(" "),t("p",[a._v("定期过期")]),a._v(" "),t("h4",{attrs:{id:"内存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[a._v("#")]),a._v(" 内存淘汰策略")]),a._v(" "),t("p",[a._v("在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据")]),a._v(" "),t("p",[a._v("1）全局的键空间选择性移除")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("allkeys-lru")]),a._v("：在键空间中，移除最近最少使用的key。（这个是最常用的）")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("allkeys-random")]),a._v("：在键空间中，随机移除某个key。")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("no-eviction")]),a._v("：当内存不足以容纳新写入数据时，新写入操作会报错。")]),a._v(" "),t("p",[a._v("2）设置过期时间的键空间选择性移除")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("volatile-lru")]),a._v("：在设置了过期时间的键空间中，移除最近最少使用的key。")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("volatile-random")]),a._v("：在设置了过期时间的键空间中，随机移除某个key。")]),a._v(" "),t("p",[a._v("​\t"),t("strong",[a._v("volatile-ttl")]),a._v("：在设置了过期时间的键空间中，有更早过期时间的key优先移除。")]),a._v(" "),t("p",[t("strong",[a._v("总结")])]),a._v(" "),t("p",[a._v("Redis的内存淘汰策略的选取并不会影响过期的key的处理。")]),a._v(" "),t("p",[a._v("内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；")]),a._v(" "),t("p",[a._v("过期策略用于处理过期的缓存数据。")]),a._v(" "),t("h3",{attrs:{id:"消息通知"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息通知"}},[a._v("#")]),a._v(" 消息通知")]),a._v(" "),t("h3",{attrs:{id:"管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[a._v("#")]),a._v(" 管道")])])}),[],!1,null,null,null);t.default=v.exports}}]);